taskKey="com.javarush.games.moonlander.part17"\n\nИгра Moon Lander (17/23)

Пришла пора реализовать реактивную тягу ракеты. На этом этапе создадим класс RocketFire, который будет отвечать
за отрисовку и анимирование огня выхлопа. Список матриц шагов анимаций будет храниться в его переменной frames типа List.
Переменная frameIndex будет хранить индекс текущей матрицы-анимации, а переменная isVisible будет отвечать за видимость огня.


Требования:
1.	Должен существовать публичный класс RocketFire.
2.	Класс RocketFire должен быть наследником класса GameObject.
3.	В классе RocketFire должно существовать приватное поле frames типа List&lt;int[][]&gt;.
4.	В классе RocketFire должно существовать приватное поле frameIndex типа int.
5.	В классе RocketFire должно существовать приватное поле isVisible типа boolean.
6.	В классе RocketFire должен существовать один публичный конструктор с одним параметром типа List&lt;int[][]&gt;.
7.	Конструктор класса RocketFire должен вызывать конструктор базового класса с параметрами 0, 0 и frameList.get(0), где frameList &ndash; параметр конструктора. Необходимо использовать ключевое слово &quot;super&quot;.
8.	Конструктор класса RocketFire должен инициализировать поле frames значением frameList.
9.	Конструктор класса RocketFire должен инициализировать поле frameIndex значением 0.
10.	Конструктор класса RocketFire должен инициализировать поле isVisible значением false.


Игра Moon Lander (17/23)

Займемся методом, отвечающим за крушение ракеты при ее пересечении с ландшафтом. Этот метод будет менять внешнее
отображение ракеты путем замены ее матрицы (матрицу ты найдешь в классе ShapeMatrix). Теперь реализуем метод gameOver.
Он должен вызвать метод crash у ракеты, показать сообщение о проигрыше и остановить игру. Кроме того, добавим перезапуск
игры при нажатии клавиши SPACE.



Игра Moon Lander (17/23)

Создадим метод land, который будет отвечать за приземление ракеты. Так как приземлением считается пересечение
ракеты и платформы, для корректного отображения нам нужно поднять ракету на одну позицию вверх, чтобы она не &quot;наезжала&quot;
на платформу. Еще нам понадобится специальное поле, которое будет отвечать за остановку игры. В начале игры значение
этого поля будет false. Когда нужно остановить игру, мы будем устанавливать ему значение true.
Теперь займемся реализацией метода win. Он должен вызвать метод land у ракеты, показать сообщение
о выигрыше и остановить игру.



Игра Moon Lander (17/23)

Для удобства проверки приземления ракеты создадим платформу(GameObject platform). При инициализации в качестве матрицы передай
ShapeMatrix.PLATFORM &mdash; ее мы добавили в класс ShapeMatrix. Теперь реализуем метод check. Он будет вызывать метод win или
gameOver в зависимости от ситуации. Когда будешь писать код метода check, для проверки пересечений ракеты с другими объектами
используй реализованный нами метод isCollision, который мы добавили в класс Rocket. Этот метод принимает в качестве параметра
объект типа GameObject и возвращает true, если ракета пересекается с этим объектом.



Игра Moon Lander (17/23)

Сейчас мы объявим несколько методов, которые пригодятся нам в будущем.
Метод check будет проверять пересечение координат ракеты и ландшафта.
Методы win и gameOver будут отвечать за выигрыш и проигрыш соответственно.
Метод isStopped будет проверять &quot;мягкость&quot; посадки. Если ракета слишком быстро приземляется на
платформу(speedY достаточно большое), метод вернет false.



Игра Moon Lander (17/23)

Как ты заметил, после отпускания клавиши движения влево или вправо ракета сразу прекращает движение, а нужно
чтобы она продолжала движение по инерции. Чтобы реализовать это, будем использовать переменную slowdown,
которая отвечает за замедление ракеты. Если мы отпускаем клавиши движения вправо или влево, в методе move
значение speedX ракеты будет плавно уменьшаться на значение slowdown, пока не достигнет 0.



