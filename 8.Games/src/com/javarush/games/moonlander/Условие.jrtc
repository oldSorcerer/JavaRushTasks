taskKey="com.javarush.games.moonlander.part19"\n\nИгра Moon Lander (19/23)

На этом этапе мы будем дорабатывать отображение анимации реактивной тяги. Добавим и реализуем метод nextFrame(), который
будет переключать кадры для создания анимации (устанавливать текущую матрицу из frames в переменную matrix).
Также переопределим метод draw, который будет менять кадр для анимации (вызвав метод nextFrame) и вызывать метод
суперкласса для отрисовки в том случае, если isVisible == true.


Требования:
1.	В классе RocketFire должен существовать приватный метод void nextFrame().
2.	В методе nextFrame() значение поля frameIndex должно увеличиваться на единицу.
3.	В методе nextFrame() значение поля frameIndex должно устанавливаться равным нулю, если значение поля frameIndex больше либо равно размеру списка frames.
4.	В методе nextFrame() значение поля matrix должно устанавливаться равным frames.get(frameIndex).
5.	В классе RocketFire должен быть переопределен метод draw(Game) родительского класса GameObject.
6.	Метод draw(Game) не должен ничего делать, если огонь не видно (isVisible == false).
7.	Метод draw(Game) должен вызывать метод nextFrame().
8.	Метод draw(Game) должен вызывать метод базового класса (super.draw(Game)) после вызова метода nextFrame().
9.	В классе RocketFire должен быть импорт всего содержимого пакета com.javarush.engine.cell.


Игра Moon Lander (19/23)

Продолжаем реализацию реактивной тяги. На этом этапе в класс Rocket мы добавим переменные, которые описывают
правую, левую и нижнюю тяги. Заполним эти поля в конструкторе соответствующими матрицами из класса ShapeMatrix,
которые мы подготовили заранее.



Игра Moon Lander (19/23)

Пришла пора реализовать реактивную тягу ракеты. На этом этапе создадим класс RocketFire, который будет отвечать
за отрисовку и анимирование огня выхлопа. Список матриц шагов анимаций будет храниться в его переменной frames типа List.
Переменная frameIndex будет хранить индекс текущей матрицы-анимации, а переменная isVisible будет отвечать за видимость огня.



Игра Moon Lander (19/23)

Займемся методом, отвечающим за крушение ракеты при ее пересечении с ландшафтом. Этот метод будет менять внешнее
отображение ракеты путем замены ее матрицы (матрицу ты найдешь в классе ShapeMatrix). Теперь реализуем метод gameOver.
Он должен вызвать метод crash у ракеты, показать сообщение о проигрыше и остановить игру. Кроме того, добавим перезапуск
игры при нажатии клавиши SPACE.



Игра Moon Lander (19/23)

Создадим метод land, который будет отвечать за приземление ракеты. Так как приземлением считается пересечение
ракеты и платформы, для корректного отображения нам нужно поднять ракету на одну позицию вверх, чтобы она не &quot;наезжала&quot;
на платформу. Еще нам понадобится специальное поле, которое будет отвечать за остановку игры. В начале игры значение
этого поля будет false. Когда нужно остановить игру, мы будем устанавливать ему значение true.
Теперь займемся реализацией метода win. Он должен вызвать метод land у ракеты, показать сообщение
о выигрыше и остановить игру.



Игра Moon Lander (19/23)

Для удобства проверки приземления ракеты создадим платформу(GameObject platform). При инициализации в качестве матрицы передай
ShapeMatrix.PLATFORM &mdash; ее мы добавили в класс ShapeMatrix. Теперь реализуем метод check. Он будет вызывать метод win или
gameOver в зависимости от ситуации. Когда будешь писать код метода check, для проверки пересечений ракеты с другими объектами
используй реализованный нами метод isCollision, который мы добавили в класс Rocket. Этот метод принимает в качестве параметра
объект типа GameObject и возвращает true, если ракета пересекается с этим объектом.



