
### Игра 2048 (18/18)

Наши поздравления: игра написана! Предлагаем запустить ее и посмотреть, что получилось.
Если есть время и вдохновение, можешь улучшить игру, добавив некоторые &quot;фичи&quot; от себя. Например:
&bull; изменить размер игрового поля;
&bull; продолжать игру, даже если найдена плитка со значением 2048;
&bull; вместо чисел 2, 4 (степени двойки) использовать числа Фибоначчи;
&bull; добавить &quot;суперплитку&quot; с возможностью слияния с любой из существующих на игровом поле;
&bull; добавить визуальные эффекты (анимацию).
Готовую игру ты можешь опубликовать на JavaRush. Но перед этим нужно отправить свое решение на проверку,
чтобы была доступна кнопка публикации. Игра будет доступна в разделе &quot;Игры&quot; всем пользователям.
А еще ты можешь поделиться ею с друзьями в соцсетях. Будет здорово, если они сыграют в твою версию &quot;2048&quot;, не так ли?
После публикации, в комментариях напиши краткую инструкцию (какие действия доступны,
какие клавиши или кнопки нужно использовать для игры), а также особенности твоей реализации.


Требования:
1.	Запусти игру.


Игра 2048 (18/18)

Думаю, ты давно заметил строку внизу игрового поля Score: 0. Судя по названию, это подсчет очков :)
Согласно правилам игры, за каждое соединение плиток игровые очки увеличиваются на значение получившейся плитки.
Для реализации этой задачи заведем переменную private int score в классе Game2048.
Ее значение будем увеличивать в методе соединения плиток mergeRow(int[]), если такое соединение произошло.
Чтобы получившееся значение score выводилось на экран, нужно вызвать метод setScore(int score) класса Game2048
и передать этому методу нашу переменную score. Не забудь обнулить очки после рестарта игры.



Игра 2048 (18/18)

Пришло время узнать, для чего нам нужен флаг isGameStopped. Он необходим для реализации механизма рестарта игры.
Если значение этого флага true &mdash; игра остановлена из-за выигрыша или проигрыша. При нажатии клавиши Key.SPACE можно делать рестарт игры.
Рестарт выполняется так же, как и старт новой игры &mdash; вызовом метода createGame(), который создает новое игровое поле.

Примечание:
Проверку возможности рестарта игры лучше проводить перед проверкой возможности хода.



Игра 2048 (18/18)

Как и о выигрыше, о проигрыше нужно сообщить. Давай это сделаем в отдельном методе void gameOver(),
по аналогии с методом win(). Если игра проиграна, флагу isGameStopped также нужно установить значение true.

В начале метода onKeyPress(Key) выполни проверку, возможен ли ход. Если ход невозможен, вызови метод gameOver() и больше ничего не делай.



Игра 2048 (18/18)

Отлично! В прошлой части мы выяснили условия, при которых игра выиграна и реализовали их.
Но есть и обратная сторона медали &mdash; проигрыш. Если на игровом поле нет плитки со
значением 2048 и нет возможности сделать ход, игроку засчитывается поражение.

Ход можно сделать, если есть хотя бы одна пустая плитка или пустых плиток нет, но есть возможность их соединения.

Вынеси эти проверки в метод canUserMove().



Игра 2048 (18/18)

Основная логика игры реализована, но не до конца. Исходя из правил и названия игры, она заканчивается
выигрышем, когда значение одной из плиток будет равно 2048.

Поиск максимального значения на игровом поле нужно вынести в отдельный метод int getMaxTileValue(), который будет
возвращать его. Проверку выигрыша можно делать где угодно. Например, в самом начале
метода createNewNumber(), перед добавлением нового значения в матрицу.

Когда найдена плитка со значением 2048, нужно сообщить игроку о выигрыше. Чтобы сделать это красиво, вызови
метод showMessageDialog(Color cellColor, String message, Color textColor, int textSize) класса Game.
Думаю, не нужно объяснять, что передавать в этот метод: названия параметров говорят сами за себя.

После победы текущая игра прекращается. В будущем нам пригодится некий флаг isGameStopped.
Если игра выиграна, он будет равен true.
Давай все вышеописанное (вывод сообщения о выигрыше, флаг остановки игры) вынесем в отдельный метод, который назовем win().



