taskKey="com.javarush.games.snake.part17"\n\nИгра змейка (17/20)

На данном этапе у нас есть один баг &mdash; яблоко может сгенерироваться на теле змейки. Для устранения бага, воспользуемся созданным
методом checkCollision(GameObject). Метод createNewApple() должен создавать новое яблоко (с новыми координатами) в цикле до тех пор,
пока результат вызова метода checkCollision(GameObject) не будет false.

Также давай реализуем рестарт игры нажатием клавиши SPACE (пробел). Игра запускается заново только если она остановлена.


Требования:
1.	Метод createNewApple() должен вызывать метод checkCollision(GameObject), передавая объект класса Apple в качестве параметра.
2.	Метод createNewApple() должен вызывать метод checkCollision(GameObject) до тех пор, пока координаты apple и любого из сегментов змеи совпадают.
3.	Метод onKeyPress(Key) должен вызывать метод createGame(), если параметр метода &mdash; клавиша SPACE, и игра была остановлена (isGameStopped == true).


Игра змейка (17/20)

Игра должна останавливаться и в случае победы. Победа наступает, когда змейка увеличивается до определённого размера. Для хранения этого размера
в классе SnakeGame создай константу GOAL и инициализируй её значением 28. Для определения текущего размера змейки в классе Snake, создай
метод getLength() и реализуй его. По аналогии с методом gameOver(), создай и реализуй метод win(). Только вместо надписи &quot;GAME OVER&quot; он должен
выводить &quot;YOU WIN&quot;. Проверка победы также производится в конце каждого хода.



Игра змейка (17/20)

Для хранения состояния игры нам понадобится переменная isGameStopped в классе SnakeGame. Проинициализируй
её в методе createGame(). Когда игра проиграна, её нужно остановить и вывести сообщение об этом игроку.
Для этого создай метод gameOver() и добавь в него команды, которые выполняются при остановке игры (проигрыше):
- вызов метода stopTurnTimer();
- присвоение флагу isGameStopped значения true;
- вывод сообщения &quot;GAME OVER&quot;.
Проверку состояния флага isGameStopped нужно проводить в конце каждого хода, и если игра остановлена, вызывать метод gameOver().



Игра змейка (17/20)

Сейчас змейка может ходить сквозь свое тело, а это не по правилам. Чтобы это исправить, нужно проверять новосозданную голову змейки на совпадение
со всеми остальными элементами её тела. Для этого в классе Snake создай метод checkCollision(GameObject). Метод checkCollision(GameObject) должен
возвращать true, если координаты переданного объекта совпадают с координатами одного из элементов тела змейки. Также в методе move(Apple) добавь
проверку на столкновения новой головы и тела. Если было столкновение, установи переменной isAlive значение false.



Игра змейка (17/20)

До этого мы устанавливали координаты яблока вручную. Необходимо создать метод для генерации новых яблок. Назовем его createNewApple().
Метод должен генерировать случайные координаты ячейки в пределах игрового поля, на которой будет появляться яблоко. Ссылку на новосозданное
яблоко присвой полю apple. Также в конце каждого хода нужно проверить, &quot;живое&quot; ли текущее яблоко, если нет &mdash; создать новое.
Для генерирования случайных чисел вызывай метод родительского класса getRandomNumber(int).



Игра змейка (17/20)

У нас уже есть змейка, которая умеет двигаться, и яблоко. Теперь реализуем их взаимодействие. Для начала добавь переменную яблока в
класс SnakeGame, и в момент создания игры инициализируй ее координатами (5, 5). Также прорисуй яблоко.

Перепиши метод move() класса Snake. Теперь в качестве аргумента он должен принимать яблоко, и если окажется, что змейка &quot;съела&quot; яблоко, состояние
яблока должно устанавливаться в &quot;неживое&quot;, а размер змейки &mdash; увеличиваться на 1 элемент.



