taskKey="com.javarush.task.task30.task3008.big21"\n\nЧат (21)

У меня есть отличнейшая новость для тебя. Компонент представление (View) уже готов. Я
добавил класс ClientGuiView. Он использует библиотеку javax.swing. Ты должен как следует
разобраться в каждой строчке этого класса. Если тебе все понятно &ndash; это замечательно, если
нет &ndash; обязательно найди ответы на свои вопросы с помощью дебага, документации или
поиска в Интернет.

Осталось написать компонент контроллер (Controller):
1)	Создай класс ClientGuiController унаследованный от Client.
2)	Создай и инициализируй поле, отвечающее за модель ClientGuiModel
model.
3)	Создай и инициализируй поле, отвечающее за представление ClientGuiView
view. Подумай, что нужно передать в конструктор при инициализации объекта.
4)	Добавь внутренний класс GuiSocketThread унаследованный от SocketThread.
Класс GuiSocketThread должен быть публичным. В нем переопредели следующие
методы:
а)	void processIncomingMessage(String message) &ndash; должен устанавливать новое
сообщение у модели и вызывать обновление вывода сообщений у
представления.
б)	void informAboutAddingNewUser(String userName) &ndash; должен добавлять нового
пользователя в модель и вызывать обновление вывода пользователей у
отображения.
в)	void informAboutDeletingNewUser(String userName) &ndash; должен удалять
пользователя из модели и вызывать обновление вывода пользователей у
отображения.
г)	void notifyConnectionStatusChanged(boolean clientConnected) &ndash; должен вызывать
аналогичный метод у представления.
5)	Переопредели методы в классе ClientGuiController:
а)	SocketThread getSocketThread() &ndash; должен создавать и возвращать объект типа
GuiSocketThread.
б)	void run() &ndash; должен получать объект SocketThread через метод getSocketThread()
и вызывать у него метод run(). Разберись, почему нет необходимости вызывать
метод run() в отдельном потоке, как мы это делали для консольного клиента.
в)	getServerAddress(), getServerPort(),getUserName(). Они должны вызывать
одноименные методы из представления (view).
6)	Реализуй метод ClientGuiModel getModel(), который должен возвращать модель.
7)	Реализуй метод main(), который должен создавать новый объект
ClientGuiController и вызывать у него метод run().
Запусти клиента с графическим окном, нескольких консольных клиентов и убедись, что
все работает корректно.


Требования:
1.	В пакете client должен быть корректно объявлен класс ClientGuiController и вложенный в него класс GuiSocketThread.
2.	В классе ClientGuiController должны быть корректно объявлены и инициализированы поля перечисленные в условии задачи.
3.	Метод processIncomingMessage() должен быть реализован в классе GuiSocketThread в соответствии с условием задачи.
4.	Метод informAboutAddingNewUser() должен быть реализован в классе GuiSocketThread в соответствии с условием задачи.
5.	Метод informAboutDeletingNewUser() должен быть реализован в классе GuiSocketThread в соответствии с условием задачи.
6.	Метод notifyConnectionStatusChanged() должен быть реализован в классе GuiSocketThread в соответствии с условием задачи.
7.	Метод getSocketThread() в классе ClientGuiController должен возвращать новый объект типа GuiSocketThread.
8.	Метод run() в классе ClientGuiController должен получать объект SocketThread через метод getSocketThread() и вызывать у него метод run().
9.	Методы getServerAddress(), getServerPort(), getUserName() в классе ClientGuiController должны вызывать соответствующие методы у объекта view.
10.	Метод getModel() в классе ClientGuiController должен возвращать значение поля model.
11.	Метод main() в классе ClientGuiController должен создавать новый объект типа ClientGuiController и вызывать у него метод run().
12.	Класс ClientGuiController должен быть потомком класса Client.


Чат (21)

Консольный клиент мы уже реализовали, чат бота тоже сделали, почему бы не сделать
клиента с графическим интерфейсом? Он будет так же работать с нашим сервером, но
иметь графическое окно, кнопки и т.д.
Итак, приступим. При написании графического клиента будет очень уместно воспользоваться
паттерном MVC (Model-View-Controller). Ты уже должен был с ним сталкиваться, если необходимо,
освежи свои знания про MVC с помощью Интернет. В нашей задаче самая простая реализация
будет у класса, отвечающего за модель (Model).

Давай напишем его:
1)	Создай класс ClientGuiModel в пакете client. Все классы клиента должны быть созданы в этом
пакете.
2)	Добавь в него множество(set) строк в качестве final поля allUserNames.
В нем будет храниться список всех участников чата. Проинициализируй его.
3)	Добавь поле String newMessage, в котором будет храниться новое сообщение,
которое получил клиент.
4)	Добавь геттер для allUserNames, запретив модифицировать возвращенное
множество. Разберись, как это можно сделать с помощью метода класса Collections.
5)	Добавь сеттер и геттер для поля newMessage.
6)	Добавь публичный метод void addUser(String newUserName), который должен добавлять
имя участника во множество, хранящее всех участников.
7)	Добавь публичный метод void deleteUser(String userName), который будет удалять имя
участника из множества.



Чат (21)

Сейчас будем реализовывать класс BotSocketThread, вернее переопределять некоторые
его методы, весь основной функционал он уже унаследовал от SocketThread.

1)	Переопредели метод clientMainLoop():
а)	С помощью метода sendTextMessage() отправь сообщение с текстом
&quot;Привет чатику. Я бот. Понимаю команды: дата, день, месяц, год, время, час, минуты, секунды.&quot;
б)	Вызови реализацию clientMainLoop() родительского класса.
2)	Переопредели метод processIncomingMessage(String message). Он должен
следующим образом обрабатывать входящие сообщения:
а)	Вывести в консоль текст полученного сообщения message.
б)	Получить из message имя отправителя и текст сообщения. Они разделены &quot;: &quot;.
в)	Отправить ответ в зависимости от текста принятого сообщения. Если текст
сообщения:
&quot;дата&quot; &ndash; отправить сообщение содержащее текущую дату в формате &quot;d.MM.YYYY&quot;;
&quot;день&quot; &ndash; в формате&quot;d&quot;;
&quot;месяц&quot; - &quot;MMMM&quot;;
&quot;год&quot; - &quot;YYYY&quot;;
&quot;время&quot; - &quot;H:mm:ss&quot;;
&quot;час&quot; - &quot;H&quot;;
&quot;минуты&quot; - &quot;m&quot;;
&quot;секунды&quot; - &quot;s&quot;.
Указанный выше формат используй для создания объекта SimpleDateFormat. Для
получения текущей даты необходимо использовать класс Calendar и метод
getTime().
Ответ должен содержать имя клиента, который прислал запрос и ожидает ответ,
например, если Боб отправил запрос &quot;время&quot;, мы должны отправить ответ
&quot;Информация для Боб: 12:30:47&quot;.

Наш бот готов. Запусти сервер, запусти бота, обычного клиента и убедись, что все работает правильно.
Помни, что message бывают разных  типов и не всегда содержат &quot;:&quot;.



Чат (21)

Иногда бывают моменты, что не находится достойного собеседника. Не общаться же с
самим собой :). Давай напишем бота, который будет представлять собой клиента, который
автоматически будет отвечать на некоторые команды. Проще всего реализовать бота,
который сможет отправлять текущее время или дату, когда его кто-то об этом попросит.

С него и начнем:
1)	Создай новый класс BotClient в пакете client. Он должен быть унаследован от
Client.
2)	В классе BotClient создай внутренний класс BotSocketThread унаследованный от
SocketThread. Класс BotSocketThread должен быть публичным.
3)	Переопредели методы:
а)	getSocketThread(). Он должен создавать и возвращать объект класса
BotSocketThread.
б)	shouldSendTextFromConsole(). Он должен всегда возвращать false. Мы не хотим,
чтобы бот отправлял текст введенный в консоль.
в)	getUserName(), метод должен генерировать новое имя бота, например:
date_bot_X, где X &ndash; любое число от 0 до 99. Для генерации X используй метод Math.random().
4)	Добавь метод main(). Он должен создавать новый объект BotClient и вызывать у
него метод run().



Чат (21)

Последний, но самый главный метод класса SocketThread &ndash; это метод void run(). Добавь
его. Его реализация с учетом уже созданных методов выглядит очень просто.

Давай напишем ее:
1)	Запроси адрес и порт сервера с помощью методов getServerAddress() и
getServerPort().
2)	Создай новый объект класса java.net.Socket, используя данные, полученные в
предыдущем пункте.
3)	Создай объект класса Connection, используя сокет из п.17.2.
4)	Вызови метод, реализующий &quot;рукопожатие&quot; клиента с сервером
(clientHandshake()).
5)	Вызови метод, реализующий основной цикл обработки сообщений сервера.
6)	При возникновении исключений IOException или ClassNotFoundException
сообщи главному потоку о проблеме, используя notifyConnectionStatusChanged() и false
в качестве параметра.

Клиент готов, можешь запустить сервер, несколько клиентов и проверить как все работает.



Чат (21)

Теперь все готово, чтобы дописать необходимые методы класса SocketThread.

1)	Добавь protected метод clientHandshake() throws IOException,
ClassNotFoundException. Этот метод будет представлять клиента серверу. Он должен:
а)	В цикле получать сообщения, используя соединение connection.
б)	Если тип полученного сообщения NAME_REQUEST (сервер запросил имя),
запросить ввод имени пользователя с помощью метода getUserName(), создать
новое сообщение с типом MessageType.USER_NAME и введенным именем, отправить
сообщение серверу.
в)	Если тип полученного сообщения MessageType.NAME_ACCEPTED (сервер принял имя), значит
сервер принял имя клиента, нужно об этом сообщить главному потоку, он этого
очень ждет. Сделай это с помощью метода notifyConnectionStatusChanged(),
передав в него true. После этого выйди из метода.
г)	Если пришло сообщение с каким-либо другим типом, кинь исключение
IOException(&quot;Unexpected MessageType&quot;).

2)	Добавь protected метод void clientMainLoop() throws IOException,
ClassNotFoundException. Этот метод будет реализовывать главный цикл обработки
сообщений сервера. Внутри метода:
а)	Получи сообщение от сервера, используя соединение connection.
б)	Если это текстовое сообщение (тип MessageType.TEXT), обработай его с помощью метода
processIncomingMessage().
в)	Если это сообщение с типом MessageType.USER_ADDED, обработай его с помощью метода
informAboutAddingNewUser().
г)	Если это сообщение с типом MessageType.USER_REMOVED, обработай его с помощью метода
informAboutDeletingNewUser().
д)	Если клиент получил сообщение какого-либо другого типа, брось исключение
IOException(&quot;Unexpected MessageType&quot;).
е)	Размести код из предыдущих пунктов внутри бесконечного цикла. Цикл будет
завершен автоматически если произойдет ошибка (будет брошено исключение) или
поток, в котором работает цикл, будет прерван.



