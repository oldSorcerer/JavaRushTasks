taskKey="com.javarush.task.task30.task3008.big19"\n\nЧат (19)

Сейчас будем реализовывать класс BotSocketThread, вернее переопределять некоторые
его методы, весь основной функционал он уже унаследовал от SocketThread.

1)	Переопредели метод clientMainLoop():
а)	С помощью метода sendTextMessage() отправь сообщение с текстом
&quot;Привет чатику. Я бот. Понимаю команды: дата, день, месяц, год, время, час, минуты, секунды.&quot;
б)	Вызови реализацию clientMainLoop() родительского класса.
2)	Переопредели метод processIncomingMessage(String message). Он должен
следующим образом обрабатывать входящие сообщения:
а)	Вывести в консоль текст полученного сообщения message.
б)	Получить из message имя отправителя и текст сообщения. Они разделены &quot;: &quot;.
в)	Отправить ответ в зависимости от текста принятого сообщения. Если текст
сообщения:
&quot;дата&quot; &ndash; отправить сообщение содержащее текущую дату в формате &quot;d.MM.YYYY&quot;;
&quot;день&quot; &ndash; в формате&quot;d&quot;;
&quot;месяц&quot; - &quot;MMMM&quot;;
&quot;год&quot; - &quot;YYYY&quot;;
&quot;время&quot; - &quot;H:mm:ss&quot;;
&quot;час&quot; - &quot;H&quot;;
&quot;минуты&quot; - &quot;m&quot;;
&quot;секунды&quot; - &quot;s&quot;.
Указанный выше формат используй для создания объекта SimpleDateFormat. Для
получения текущей даты необходимо использовать класс Calendar и метод
getTime().
Ответ должен содержать имя клиента, который прислал запрос и ожидает ответ,
например, если Боб отправил запрос &quot;время&quot;, мы должны отправить ответ
&quot;Информация для Боб: 12:30:47&quot;.

Наш бот готов. Запусти сервер, запусти бота, обычного клиента и убедись, что все работает правильно.
Помни, что message бывают разных  типов и не всегда содержат &quot;:&quot;.


Требования:
1.	Метод clientMainLoop()класса BotSocketThread должен вызывать метод sendTextMessage() у внешнего объекта BotClient c приветственным сообщением указанном в условии задачи.
2.	Метод clientMainLoop() класса BotSocketThread должен вызывать clientMainLoop() у объекта родительского класса (super).
3.	Метод processIncomingMessage() должен выводить на экран полученное сообщение message.
4.	Метод processIncomingMessage() должен отправлять ответ с помощью метода sendTextMessage() (форматирование согласно условию задачи).
5.	Метод processIncomingMessage() не должен вызывать метод sendTextMessage() для некорректных запросов.


Чат (19)

Иногда бывают моменты, что не находится достойного собеседника. Не общаться же с
самим собой :). Давай напишем бота, который будет представлять собой клиента, который
автоматически будет отвечать на некоторые команды. Проще всего реализовать бота,
который сможет отправлять текущее время или дату, когда его кто-то об этом попросит.

С него и начнем:
1)	Создай новый класс BotClient в пакете client. Он должен быть унаследован от
Client.
2)	В классе BotClient создай внутренний класс BotSocketThread унаследованный от
SocketThread. Класс BotSocketThread должен быть публичным.
3)	Переопредели методы:
а)	getSocketThread(). Он должен создавать и возвращать объект класса
BotSocketThread.
б)	shouldSendTextFromConsole(). Он должен всегда возвращать false. Мы не хотим,
чтобы бот отправлял текст введенный в консоль.
в)	getUserName(), метод должен генерировать новое имя бота, например:
date_bot_X, где X &ndash; любое число от 0 до 99. Для генерации X используй метод Math.random().
4)	Добавь метод main(). Он должен создавать новый объект BotClient и вызывать у
него метод run().



Чат (19)

Последний, но самый главный метод класса SocketThread &ndash; это метод void run(). Добавь
его. Его реализация с учетом уже созданных методов выглядит очень просто.

Давай напишем ее:
1)	Запроси адрес и порт сервера с помощью методов getServerAddress() и
getServerPort().
2)	Создай новый объект класса java.net.Socket, используя данные, полученные в
предыдущем пункте.
3)	Создай объект класса Connection, используя сокет из п.17.2.
4)	Вызови метод, реализующий &quot;рукопожатие&quot; клиента с сервером
(clientHandshake()).
5)	Вызови метод, реализующий основной цикл обработки сообщений сервера.
6)	При возникновении исключений IOException или ClassNotFoundException
сообщи главному потоку о проблеме, используя notifyConnectionStatusChanged() и false
в качестве параметра.

Клиент готов, можешь запустить сервер, несколько клиентов и проверить как все работает.



Чат (19)

Теперь все готово, чтобы дописать необходимые методы класса SocketThread.

1)	Добавь protected метод clientHandshake() throws IOException,
ClassNotFoundException. Этот метод будет представлять клиента серверу. Он должен:
а)	В цикле получать сообщения, используя соединение connection.
б)	Если тип полученного сообщения NAME_REQUEST (сервер запросил имя),
запросить ввод имени пользователя с помощью метода getUserName(), создать
новое сообщение с типом MessageType.USER_NAME и введенным именем, отправить
сообщение серверу.
в)	Если тип полученного сообщения MessageType.NAME_ACCEPTED (сервер принял имя), значит
сервер принял имя клиента, нужно об этом сообщить главному потоку, он этого
очень ждет. Сделай это с помощью метода notifyConnectionStatusChanged(),
передав в него true. После этого выйди из метода.
г)	Если пришло сообщение с каким-либо другим типом, кинь исключение
IOException(&quot;Unexpected MessageType&quot;).

2)	Добавь protected метод void clientMainLoop() throws IOException,
ClassNotFoundException. Этот метод будет реализовывать главный цикл обработки
сообщений сервера. Внутри метода:
а)	Получи сообщение от сервера, используя соединение connection.
б)	Если это текстовое сообщение (тип MessageType.TEXT), обработай его с помощью метода
processIncomingMessage().
в)	Если это сообщение с типом MessageType.USER_ADDED, обработай его с помощью метода
informAboutAddingNewUser().
г)	Если это сообщение с типом MessageType.USER_REMOVED, обработай его с помощью метода
informAboutDeletingNewUser().
д)	Если клиент получил сообщение какого-либо другого типа, брось исключение
IOException(&quot;Unexpected MessageType&quot;).
е)	Размести код из предыдущих пунктов внутри бесконечного цикла. Цикл будет
завершен автоматически если произойдет ошибка (будет брошено исключение) или
поток, в котором работает цикл, будет прерван.



Чат (19)

Напишем реализацию класса SocketThread. Начнем с простых вспомогательных методов.

Добавь методы, которые будут доступны классам потомкам и не доступны остальным
классам вне пакета:
1)	void processIncomingMessage(String message) &ndash; должен выводить текст message в
консоль.
2)	void informAboutAddingNewUser(String userName) &ndash; должен выводить в консоль
информацию о том, что участник с именем userName присоединился к чату.
3)	void informAboutDeletingNewUser(String userName) &ndash; должен выводить в
консоль, что участник с именем userName покинул чат.
4)	void notifyConnectionStatusChanged(boolean clientConnected) &ndash; этот метод
должен:
а)	Устанавливать значение поля clientConnected внешнего объекта Client в соответствии с
переданным параметром.
б)	Оповещать (пробуждать ожидающий) основной поток класса Client. Подсказка:
используй синхронизацию на уровне текущего объекта внешнего класса и метод notify(). Для
класса SocketThread внешним классом является класс Client.



Чат (19)

Приступим к написанию главного функционала класса Client.

1)	Добавь метод public void run(). Он должен создавать вспомогательный поток
SocketThread, ожидать пока тот установит соединение с сервером, а после этого
в цикле считывать сообщения с консоли и отправлять их серверу. Условием выхода
из цикла будет отключение клиента или ввод пользователем команды &#39;exit&#39;.
Для информирования главного потока, что соединение установлено во
вспомогательном потоке, используй методы wait() и notify() объекта класса Client.

Реализация метода run должна:
а)  Создавать новый сокетный поток с помощью метода getSocketThread().
б)	Помечать созданный поток как daemon, это нужно для того, чтобы при выходе
из программы вспомогательный поток прервался автоматически.
в)	Запустить вспомогательный поток.
г)	Заставить текущий поток ожидать, пока он не получит нотификацию из другого
потока. Подсказка: используй wait() и синхронизацию на уровне объекта. Если во
время ожидания возникнет исключение, сообщи об этом пользователю и выйди
из программы.
д)	После того, как поток дождался нотификации, проверь значение
clientConnected. Если оно true &ndash; выведи &quot;Соединение установлено. Для выхода
наберите команду &#39;exit&#39;.&quot;. Если оно false &ndash; выведи &quot;Произошла ошибка во время
работы клиента.&quot;.
е)	Считывай сообщения с консоли пока клиент подключен. Если будет введена
команда &#39;exit&#39;, то выйди из цикла.
ж)	После каждого считывания, если метод shouldSendTextFromConsole()
возвращает true, отправь считанный текст с помощью метода  sendTextMessage().

2)	Добавь метод public static void main(String[] args). Он должен создавать новый объект типа Client и
вызывать у него метод run().



