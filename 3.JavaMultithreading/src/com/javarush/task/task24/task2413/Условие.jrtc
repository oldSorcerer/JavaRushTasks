taskKey="com.javarush.task.task24.task2413.big09"\n\nАрканоид(9)

Теперь займемся классом Canvas.
Он у нас будет содержать матрицу(двумерный массив), куда мы будем &quot;рисовать&quot;.
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).

Надо:
а) Добавить в класс два приватных поля width и height.
б) Добавить в класс приватное поле matrix (char[][]).
в) Добавить конструктор с двумя параметрами типа int (width и height), поле matrix должно быть инициализировано пустым массивом размерностью [height+2][width+2].
г) Добавить геттеры и сеттеры для всех приватных полей класса.



Требования:
1.	В классе Canvas должно быть создано приватное поле width типа int.
2.	В классе Canvas должно быть создано приватное поле height типа int.
3.	В классе Canvas должно быть создано приватное поле matrix типа char[][].
4.	В классе Canvas должен быть создан публичный геттер для поля width.
5.	В классе Canvas должен быть создан публичный геттер для поля height.
6.	В классе Canvas должен быть создан публичный геттер для поля matrix.
7.	В классе Canvas должен быть создан публичный сеттер для поля width.
8.	В классе Canvas должен быть создан публичный сеттер для поля height.
9.	В классе Canvas должен быть создан публичный сеттер для поля matrix.
10.	В классе Canvas должен быть создан корректный публичный конструктор с двумя параметрами типа int (width и height).


Арканоид(9)

Но и это еще не все.
Классу BaseObject нужны еще методы.
Пока это будут пустые методы draw(Canvas canvas) и move().
Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность (пока можешь оставить их пустыми, просто чтобы код компилировался).
Объяви эти методы, но сделай их абстрактными.
Также сделай абстрактным сам класс BaseObject.

А еще нам нужно будет определять попал ли шарик в кирпич или в подставку.
Это будем делать так:
В этом же классе, создадим специальный метод: boolean intersects(BaseObject o)
Он будет определять - &quot;пересеклись&quot; объекты или нет. Если пересеклись - возвращать true, если нет - false.

Т.к. объекты мы условно считаем кругами, то предлагаю такую формулу взаимодействия:
если центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.
Или еще проще:
дистанция_между_объектами &lt;= max (радиус_первого_объекта, радиус_второго_объекта)

Дистанция между объектами A и B на плоскости вычисляется по теореме Пифагора по формуле:
дистанция_между_объектами_A_B = квадратный_корень(квадрат_числа(координата_x_объекта_B - координата_x_объекта_A) + квадрат_числа(координата_y_объекта_B - координата_y_объекта_A))
Квадратный корень можно получить используя метод Math.sqrt(). Квадрат числа можно получить используя метод Math.pow(), где первый аргумент - это число,
второй аргумент - степень, к которой нужно возвести число.

Или еще проще используя метод Math.hypot().



Арканоид(9)

Теперь перейдем к классу BaseObject.
Я хочу сделать несколько предложений.

Во-первых для простоты считать что все объекты у нас будут круглыми.
Нет, отрисовывать их мы будем фигурными, как и раньше.
А вот при расчетах из взаимодействия исходить из того, что они круглые.
Так - гораздо проще.

Во-вторых. Пусть координаты объектов и радиус будут вещественными числами.
Это придаст плавность движениям и точность всем вычислениям.
А при отрисовке мы будем их округлять.

Итак:
а) Добавь в класс BaseObject приватные поля x (double), y (double), radius (double).
б) Добавь геттеры и сеттеры.
в) Добавь конструктор BaseObject(double x, double y, double radius).
г) Пройдись по всем классам-наследникам и поправь у них конструкторы.

Если ты используешь Intellij IDEA - Alt+Insert тебе в помощь.



Арканоид(9)

У нас будут &quot;кирпичи&quot;, &quot;шарик&quot; и &quot;подставка&quot; и у них будет много общего.
Они будут перемещаться по полю и отрисовываться.
Значит у них у всех будут координаты и размер.
А еще методы move() - для перемещения и draw() для отрисовки.

Есть интересное предложение: давай введем один базовый класс для всех объектов.
Пусть это будет класс BaseObject.
А классы Ball, Stand, Brick от него наследуются.

Создай класс BaseObject и добавь его родителем к классам  Ball, Stand, Brick.

Еще нам понадобится класс Canvas.
Он будет ответственным за &quot;отрисовку&quot; объектов.
С помощью его они будут отрисовывать себя.
Вернее даже на нем, но детали я сообщу позднее.

Создай и этот класс.



Арканоид(9)

Чего еще не хватает классу Arkanoid?
Во-первых ему нужен метод run(), в котором будет описана основная логика программы.
Еще нужен метод move() - который будет двигать на один шаг все объекты требующие движения.
Создай методы run() и move().

Еще нам понадобится НЕ приватная статическая переменная game типа Arkanoid, которая будет хранить ссылку
на созданный экземпляр класса Arkanoid.
Выглядеть это должно примерно так:
static Arkanoid game;



Арканоид(9)

Также классу Arkanoid нужно будет хранить ссылку на шарик (Ball), &quot;подставку&quot; Stand и список &quot;кирпичей&quot;.

Нужно в классе Arkanoid:
а) создать приватное поле ball типа Ball
б) создать приватное поле stand типа Stand
в) создать приватное поле bricks типа List&lt;Brick&gt;
г) добавить для них публичные геттеры и сеттеры



