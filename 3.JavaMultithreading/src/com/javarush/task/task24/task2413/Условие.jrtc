taskKey="com.javarush.task.task24.task2413.big12"\n\nАрканоид(12)

Теперь займемся классом Brick.

Во-первых, в конструкторе точно зададим &quot;радиус&quot; всех кирпичей.
Путь он выглядит так:
public Brick(double x, double y) {
super(x, y, 3);
}

Еще убедись, что в классе Brick есть два переопределенных метода: move() и draw(Canvas canvas).
Метод move() не делает ничего (не содержит кода), т.к. кирпич никуда не двигается.

Кодом метода draw(Canvas canvas) я займусь сам.


Требования:
1.	Конструктор класса Brick должен принимать два параметра типа double и вызывать конструктор класса родителя с фиксированным третьим параметром (радиусом) равным 3.
2.	В классе Brick должен существовать метод move без параметров.
3.	В классе Brick должен существовать метод draw с одним параметром типа Сanvas.


Арканоид(12)

Еще Canvas понадобится два метода, напиши их.
а) метод clear()
Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
Можешь просто заново инициализировать matrix пустым массивом правильной размерности.

б) метод print()
Этот метод рисует матрицу на экран.
Тут уже ты должен сам разобраться: вывести набор символов не так уж и сложно.



Арканоид(12)

Что мы будем делать с Canvas?
Мы будем рисовать на нем (в его матрице).
Поэтому нам понадобятся два метода:
void setPoint(double x, double y, char c)
void drawMatrix(double x, double y, int[][] matrix, char c)

Первый метод - setPoint будет &quot;ставить точку в координатах x,y цветом c&quot;.
В методе надо:
а) округлить x и y до целых чисел, используя метод Math.round()
б) занести в matrix[y][x] значение с
в) ничего не делать, если x &lt; 0 или y &lt; 0 или y &gt;= matrix.length или x &gt;= matrix[0].length

Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
И не просто копирует, а начиная с координат x, y
В методе надо:
а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки
б) если значение ячейки элемента [i][j] полученной матрицы не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
setPoint(x+j, y+i, c)




Арканоид(12)

Теперь займемся классом Canvas.
Он у нас будет содержать матрицу(двумерный массив), куда мы будем &quot;рисовать&quot;.
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).

Надо:
а) Добавить в класс два приватных поля width и height.
б) Добавить в класс приватное поле matrix (char[][]).
в) Добавить конструктор с двумя параметрами типа int (width и height), поле matrix должно быть инициализировано пустым массивом размерностью [height+2][width+2].
г) Добавить геттеры и сеттеры для всех приватных полей класса.




Арканоид(12)

Но и это еще не все.
Классу BaseObject нужны еще методы.
Пока это будут пустые методы draw(Canvas canvas) и move().
Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность (пока можешь оставить их пустыми, просто чтобы код компилировался).
Объяви эти методы, но сделай их абстрактными.
Также сделай абстрактным сам класс BaseObject.

А еще нам нужно будет определять попал ли шарик в кирпич или в подставку.
Это будем делать так:
В этом же классе, создадим специальный метод: boolean intersects(BaseObject o)
Он будет определять - &quot;пересеклись&quot; объекты или нет. Если пересеклись - возвращать true, если нет - false.

Т.к. объекты мы условно считаем кругами, то предлагаю такую формулу взаимодействия:
если центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.
Или еще проще:
дистанция_между_объектами &lt;= max (радиус_первого_объекта, радиус_второго_объекта)

Дистанция между объектами A и B на плоскости вычисляется по теореме Пифагора по формуле:
дистанция_между_объектами_A_B = квадратный_корень(квадрат_числа(координата_x_объекта_B - координата_x_объекта_A) + квадрат_числа(координата_y_объекта_B - координата_y_объекта_A))
Квадратный корень можно получить используя метод Math.sqrt(). Квадрат числа можно получить используя метод Math.pow(), где первый аргумент - это число,
второй аргумент - степень, к которой нужно возвести число.

Или еще проще используя метод Math.hypot().



Арканоид(12)

Теперь перейдем к классу BaseObject.
Я хочу сделать несколько предложений.

Во-первых для простоты считать что все объекты у нас будут круглыми.
Нет, отрисовывать их мы будем фигурными, как и раньше.
А вот при расчетах из взаимодействия исходить из того, что они круглые.
Так - гораздо проще.

Во-вторых. Пусть координаты объектов и радиус будут вещественными числами.
Это придаст плавность движениям и точность всем вычислениям.
А при отрисовке мы будем их округлять.

Итак:
а) Добавь в класс BaseObject приватные поля x (double), y (double), radius (double).
б) Добавь геттеры и сеттеры.
в) Добавь конструктор BaseObject(double x, double y, double radius).
г) Пройдись по всем классам-наследникам и поправь у них конструкторы.

Если ты используешь Intellij IDEA - Alt+Insert тебе в помощь.



