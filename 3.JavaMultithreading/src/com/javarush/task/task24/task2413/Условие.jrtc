taskKey="com.javarush.task.task24.task2413.big16"\n\nАрканоид(16)

И наконец &quot;подставка&quot;!
Ей понадобятся такие приватные поля:
а) speed (скорость подставки) типа double;
б) direction (направление движения по оси x: 1 - вправо, -1 - влево, 0 - начальное значение, стоим на месте) типа double.

Также создай для них геттеры.

А еще с тебя конструктор, примерно вот такой:
public Stand(double x, double y) {
super(x, y, 3);
speed = 1;
direction = 0;
}


Требования:
1.	В классе Stand должно быть создано приватное поле speed типа double.
2.	В классе Stand должно быть создано приватное поле direction типа double.
3.	В классе Stand должен быть реализован публичный геттер для поля speed.
4.	В классе Stand должен быть реализован публичный геттер для поля direction.
5.	В классе Stand должен быть реализован конструктор с двумя параметрами типа double в соответствии с условием задачи.


Арканоид(16)

Не поверишь, но и это еще не все.
Продолжим реализацию класса Ball.

Во-первых нужен метод setDirection,
который не только устанавливает значение переменной direction,
но и вычисляет новые значения переменных dx и dy.

Код должен выглядеть примерно так:
this.direction = direction;
double angle = Math.toRadians(direction);
dx = Math.cos(angle) * speed;
dy = -Math.sin(angle) * speed.

Во-вторых шарик может удариться о стенку.
При этом он должен от нее отскочить.
Для этого нам понадобится еще один метод:
void checkRebound(int minx, int maxx, int miny, int maxy)
Создай его, а кодом я займусь сам.



Арканоид(16)

Чего-то не хватает в классе Ball:

Во-первых надо реализовать метод move(), унаследованный от BaseObject:
а) x должен увеличиваться на dx каждый ход
б) y должен увеличиваться на dy каждый ход
если шарик &quot;заморожен&quot;, то x и y меняться не должны

Во-вторых надо реализовать метод draw(Canvas canvas):
на объекте canvas необходимо вызвать метод setPoint с параметрами (x, y, &#39;O&#39;)

В-третьих надо создать и реализовать метод void start():
именно его вызов &quot;размораживает&quot; шарик.
Что для этого надо сделать - это ты уже сам реши.

P.S. Чуть не забыл! Поля x, y и radius объявлены в классе BaseObject с модификатором доступа private,
что не очень-то удобно. Измени его на protected, чтобы все потомки класса BaseObject имели контроль над своими
координатами и размерами, без необходимости пользоваться &quot;чужими&quot; геттерами и сеттерами.



Арканоид(16)

Класс Ball уже посложнее - шарик же двигается.

Нам понадобятся приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения в градусах: от 0 до 360) типа double;
в) dx (расстояние по x, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
г) dy (расстояние по y, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
д) isFrozen (&quot;истина&quot; если шарик &quot;заморожен&quot; - не двигается) типа boolean.

Не забудь добавить геттеры для всех полей этого класса, кроме isFrozen (его мы будем использовать только внутри класса Ball).

А еще сделай-ка конструктор:
а) параметры - x, y, speed, direction;
б) радиус (для вызова родительского класса) всегда равен 1;
в) не забудь установить isFrozen в true - в начале игры шарик никуда не летит.



Арканоид(16)

Теперь займемся классом Brick.

Во-первых, в конструкторе точно зададим &quot;радиус&quot; всех кирпичей.
Путь он выглядит так:
public Brick(double x, double y) {
super(x, y, 3);
}

Еще убедись, что в классе Brick есть два переопределенных метода: move() и draw(Canvas canvas).
Метод move() не делает ничего (не содержит кода), т.к. кирпич никуда не двигается.

Кодом метода draw(Canvas canvas) я займусь сам.



Арканоид(16)

Еще Canvas понадобится два метода, напиши их.
а) метод clear()
Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
Можешь просто заново инициализировать matrix пустым массивом правильной размерности.

б) метод print()
Этот метод рисует матрицу на экран.
Тут уже ты должен сам разобраться: вывести набор символов не так уж и сложно.



