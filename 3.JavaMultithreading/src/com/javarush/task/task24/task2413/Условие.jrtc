taskKey="com.javarush.task.task24.task2413.big14"\n\nАрканоид(14)

Чего-то не хватает в классе Ball:

Во-первых надо реализовать метод move(), унаследованный от BaseObject:
а) x должен увеличиваться на dx каждый ход
б) y должен увеличиваться на dy каждый ход
если шарик &quot;заморожен&quot;, то x и y меняться не должны

Во-вторых надо реализовать метод draw(Canvas canvas):
на объекте canvas необходимо вызвать метод setPoint с параметрами (x, y, &#39;O&#39;)

В-третьих надо создать и реализовать метод void start():
именно его вызов &quot;размораживает&quot; шарик.
Что для этого надо сделать - это ты уже сам реши.

P.S. Чуть не забыл! Поля x, y и radius объявлены в классе BaseObject с модификатором доступа private,
что не очень-то удобно. Измени его на protected, чтобы все потомки класса BaseObject имели контроль над своими
координатами и размерами, без необходимости пользоваться &quot;чужими&quot; геттерами и сеттерами.


Требования:
1.	Метод move() в классе Ball должен увеличивать значение x на dx, если значение поля isFrozen равно false.
2.	Метод move() в классе Ball должен увеличивать значение y на dy, если значение поля isFrozen равно false.
3.	Метод move() в классе Ball не должен менять значения полей x и y, если значение поля isFrozen равно true.
4.	В классе Ball должен быть реализован метод draw(Canvas canvas) в соответствии с условием задачи.
5.	В классе Ball должен быть реализован метод start() устанавливающий значение поля isFrozen в false.
6.	Модификатор доступа поля x в классе BaseObject должен быть изменен на protected.
7.	Модификатор доступа поля y в классе BaseObject должен быть изменен на protected.
8.	Модификатор доступа поля radius в классе BaseObject должен быть изменен на protected.


Арканоид(14)

Класс Ball уже посложнее - шарик же двигается.

Нам понадобятся приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения в градусах: от 0 до 360) типа double;
в) dx (расстояние по x, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
г) dy (расстояние по y, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
д) isFrozen (&quot;истина&quot; если шарик &quot;заморожен&quot; - не двигается) типа boolean.

Не забудь добавить геттеры для всех полей этого класса, кроме isFrozen (его мы будем использовать только внутри класса Ball).

А еще сделай-ка конструктор:
а) параметры - x, y, speed, direction;
б) радиус (для вызова родительского класса) всегда равен 1;
в) не забудь установить isFrozen в true - в начале игры шарик никуда не летит.



Арканоид(14)

Теперь займемся классом Brick.

Во-первых, в конструкторе точно зададим &quot;радиус&quot; всех кирпичей.
Путь он выглядит так:
public Brick(double x, double y) {
super(x, y, 3);
}

Еще убедись, что в классе Brick есть два переопределенных метода: move() и draw(Canvas canvas).
Метод move() не делает ничего (не содержит кода), т.к. кирпич никуда не двигается.

Кодом метода draw(Canvas canvas) я займусь сам.



Арканоид(14)

Еще Canvas понадобится два метода, напиши их.
а) метод clear()
Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
Можешь просто заново инициализировать matrix пустым массивом правильной размерности.

б) метод print()
Этот метод рисует матрицу на экран.
Тут уже ты должен сам разобраться: вывести набор символов не так уж и сложно.



Арканоид(14)

Что мы будем делать с Canvas?
Мы будем рисовать на нем (в его матрице).
Поэтому нам понадобятся два метода:
void setPoint(double x, double y, char c)
void drawMatrix(double x, double y, int[][] matrix, char c)

Первый метод - setPoint будет &quot;ставить точку в координатах x,y цветом c&quot;.
В методе надо:
а) округлить x и y до целых чисел, используя метод Math.round()
б) занести в matrix[y][x] значение с
в) ничего не делать, если x &lt; 0 или y &lt; 0 или y &gt;= matrix.length или x &gt;= matrix[0].length

Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
И не просто копирует, а начиная с координат x, y
В методе надо:
а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки
б) если значение ячейки элемента [i][j] полученной матрицы не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
setPoint(x+j, y+i, c)




Арканоид(14)

Теперь займемся классом Canvas.
Он у нас будет содержать матрицу(двумерный массив), куда мы будем &quot;рисовать&quot;.
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).

Надо:
а) Добавить в класс два приватных поля width и height.
б) Добавить в класс приватное поле matrix (char[][]).
в) Добавить конструктор с двумя параметрами типа int (width и height), поле matrix должно быть инициализировано пустым массивом размерностью [height+2][width+2].
г) Добавить геттеры и сеттеры для всех приватных полей класса.




