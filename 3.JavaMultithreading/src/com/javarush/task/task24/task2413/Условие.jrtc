taskKey="com.javarush.task.task24.task2413.big18"\n\nАрканоид(18)

Теперь вернемся к классу Arkanoid.

Реализуй метод move():
В этом методе нужно двигать все движимые объекты (stand, ball).
Создай и реализуй метод void draw(Canvas canvas)
В этом методе надо вызвать метод draw всех существующих объектов, которые его имеют.


Требования:
1.	В классе Arkanoid должен быть реализован метод move() без параметров, вызывающий методы move() у шарика и подставки.
2.	В классе Arkanoid должен быть реализован метод draw(Canvas canvas), вызывающий методы draw у шарика, подставки и всех кирпичей.


Арканоид(18)

Еще подставке нужны методы:
а) move - см. move в BaseObject
Движение доски осуществляется горизонтально, поэтому мы меняем только координату х.
Подумай, как координата х зависит от направления (direction) и скорости (speed). Реализуй зависимость.
б) draw - см. draw в BaseObject
Его кодом я займусь сам.
в) moveLeft() - задает постоянное движение &quot;подставки&quot; влево
Просто присвой правильное значение переменной direction.
г) moveRight() - задает постоянное движение &quot;подставки&quot; вправо
Просто присвой правильное значение переменной direction.



Арканоид(18)

И наконец &quot;подставка&quot;!
Ей понадобятся такие приватные поля:
а) speed (скорость подставки) типа double;
б) direction (направление движения по оси x: 1 - вправо, -1 - влево, 0 - начальное значение, стоим на месте) типа double.

Также создай для них геттеры.

А еще с тебя конструктор, примерно вот такой:
public Stand(double x, double y) {
super(x, y, 3);
speed = 1;
direction = 0;
}



Арканоид(18)

Не поверишь, но и это еще не все.
Продолжим реализацию класса Ball.

Во-первых нужен метод setDirection,
который не только устанавливает значение переменной direction,
но и вычисляет новые значения переменных dx и dy.

Код должен выглядеть примерно так:
this.direction = direction;
double angle = Math.toRadians(direction);
dx = Math.cos(angle) * speed;
dy = -Math.sin(angle) * speed.

Во-вторых шарик может удариться о стенку.
При этом он должен от нее отскочить.
Для этого нам понадобится еще один метод:
void checkRebound(int minx, int maxx, int miny, int maxy)
Создай его, а кодом я займусь сам.



Арканоид(18)

Чего-то не хватает в классе Ball:

Во-первых надо реализовать метод move(), унаследованный от BaseObject:
а) x должен увеличиваться на dx каждый ход
б) y должен увеличиваться на dy каждый ход
если шарик &quot;заморожен&quot;, то x и y меняться не должны

Во-вторых надо реализовать метод draw(Canvas canvas):
на объекте canvas необходимо вызвать метод setPoint с параметрами (x, y, &#39;O&#39;)

В-третьих надо создать и реализовать метод void start():
именно его вызов &quot;размораживает&quot; шарик.
Что для этого надо сделать - это ты уже сам реши.

P.S. Чуть не забыл! Поля x, y и radius объявлены в классе BaseObject с модификатором доступа private,
что не очень-то удобно. Измени его на protected, чтобы все потомки класса BaseObject имели контроль над своими
координатами и размерами, без необходимости пользоваться &quot;чужими&quot; геттерами и сеттерами.



Арканоид(18)

Класс Ball уже посложнее - шарик же двигается.

Нам понадобятся приватные поля:
а) speed (скорость шарика) типа double;
б) direction (направление движения в градусах: от 0 до 360) типа double;
в) dx (расстояние по x, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
г) dy (расстояние по y, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double;
д) isFrozen (&quot;истина&quot; если шарик &quot;заморожен&quot; - не двигается) типа boolean.

Не забудь добавить геттеры для всех полей этого класса, кроме isFrozen (его мы будем использовать только внутри класса Ball).

А еще сделай-ка конструктор:
а) параметры - x, y, speed, direction;
б) радиус (для вызова родительского класса) всегда равен 1;
в) не забудь установить isFrozen в true - в начале игры шарик никуда не летит.



