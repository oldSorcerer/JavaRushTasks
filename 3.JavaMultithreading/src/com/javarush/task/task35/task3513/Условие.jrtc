taskKey="com.javarush.task.task35.task3513.big11"\n\n2048 (11)

Отличная работа! На этом этапе у нас уже есть полнофункциональное приложение, но ведь нет предела совершенству,
давай еще поработаем.

Если ты успел какое-то время поиграть в 2048, то заметил, что порой очень хочется иметь возможность отменить
последний ход.

Давай создадим в классе Model два стека, в одном будем хранить предыдущие состояния игрового поля, а в другом
предыдущие счета. Назовем их previousStates и previousScores. Инициализировать можешь прямо в строке объявления
или в конструкторе. Используй стандартную реализацию стека (java.util.Stack).

Добавим boolean поле isSaveNeeded = true, оно нам понадобится в будущем.

Хранилище состояний у нас есть, теперь реализуем два метода для работы с ними.
1. Приватный метод saveState с одним параметром типа Tile[][] будет сохранять текущее
игровое состояние и счет в стеки с помощью метода push и устанавливать флаг isSaveNeeded равным false.
2. Публичный метод rollback будет устанавливать текущее игровое состояние равным последнему находящемуся
в стеках с помощью метода pop.

Обрати внимание на то, что при сохранении массива gameTiles необходимо создать новый массив и заполнить его
новыми объектами типа Tile перед сохранением в стек.

В методе rollback достаточно просто выполнить присваивание (gameTiles = previousStates.pop()) и то же для счета,
нет необходимости в глубоком копировании.

Перед восстановлением игрового состояния с помощью метода rollback не забудь проверить что стеки не пусты,
чтобы избежать возникновения исключения EmptyStackException.


Требования:
1.	В классе Model должны быть объявлены и инициализированы приватные поля previousStates, previousScores, isSaveNeeded.
2.	Метод saveState должен сохранять в стек previousStates новый объект типа Tile[][] с помощью метода push.
3.	После вызова метода saveState веса плиток в массиве который находится на вершине стека должны совпадать с весами плиток массива полученного в качестве параметра.
4.	Метод saveState должен сохранять в стек previousScores текущее значение поля score с помощью метода push.
5.	Метод saveState должен устанавливать флаг isSaveNeeded равным false.
6.	Метод rollback должен восстанавливать поля score и gameTiles из соответствующих стеков, если они не пусты.
7.	Метод rollback не должен модифицировать текущее игровое состояние в случае, если хотя бы один из стеков пуст.
8.	Каждый вызов метода saveState должен увеличивать количество элементов в стеках на единицу.
9.	Каждый вызов метода rollback должен уменьшать количество элементов в стеках на единицу, до тех пор пока это возможно.


2048 (11)

Пора приступить к реализации метода main в классе Main, чтобы иметь возможность наконец-то запустить игру и отдохнуть!

Метод main нам нужен только для того чтобы запустить приложение, все внутренности мы уже реализовали.
Для этого мы создадим в нем модель и контроллер, а также объект типа JFrame. Для примера я назову его game,
но ты можешь выбрать любое другое имя.

У нашей игры (объекта типа JFrame) мы должны будем вызвать некоторые методы для того чтобы все корректно отображалось
на экране:

game.setTitle(&quot;2048&quot;);
game.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
game.setSize(450, 500);
game.setResizable(false);

game.add(controller.getView());

game.setLocationRelativeTo(null);
game.setVisible(true);

Обрати внимание на метод add в который мы передаем представление из контроллера. У нас еще нет геттера для поля view
в классе Controller. Не забудь его добавить.

P.S. Результатом выполнения этого задания будет рабочая версия игры 2048, если у тебя вдруг что-то не работает,
или работает не так как ожидалось, обязательно разберись и исправь прежде чем переходить к следующим задачам.



2048 (11)

Ты отлично справляешься! Так хорошо, что я решил тебе немного помочь и уже реализовал класс View.
Он достаточно прост. Наследуемся от класса JPanel, переопределяем метод paint и выводим на экран
текущее состояние модели, полученное через контроллер.

Тебе же, предстоит закончить реализацию класса Controller.

Для начала нам понадобится конструктор, он будет принимать один параметр типа Model, инициализировать поле
model, а также сохранять в поле view новый объект типа View с текущим контроллером(this) в качестве параметра
конструктора.

Далее, нам нужен метод resetGame, который позволит вернуть игровое поле в начальное состояние.
Необходимо обнулить счет, установить флаги isGameWon и isGameLost у представления в false и вызывать метод
resetGameTiles у модели. Примечание: устанавливай значение полей напрямую, без использования сеттеров.

Добавим приватную константу int WINNING_TILE = 2048. Она будет определять вес плитки при достижении которого
игра будет считаться выигранной.

Ну а теперь, самое главное! Для того чтобы иметь возможность обрабатывать пользовательский ввод, необходимо
переопределить метод keyPressed с одним параметром типа KeyEvent.
Логика метода должна быть следующей:
1) Если была нажата клавиша ESC - вызови метод resetGame.
2) Если метод canMove модели возвращает false - установи флаг isGameLost в true.
3) Если оба флага isGameLost и isGameWon равны false - обработай варианты движения:
а) для клавиши KeyEvent.VK_LEFT вызови метод left у модели;
б) для клавиши KeyEvent.VK_RIGHT вызови метод right у модели;
в) для клавиши KeyEvent.VK_UP вызови метод up у модели;
г) для клавиши KeyEvent.VK_DOWN вызови метод down у модели.
4) Если поле maxTile у модели стало равно WINNING_TILE, установи флаг isGameWon в true.
5) В самом конце, вызови метод repaint у view.

P.S. Для получения кода нажатой клавиши используй метод getKeyCode класса KeyEvent.



2048 (11)

Итак, модель почти готова, добавим еще пару простых методов и начнем реализацию контроллера.

В модели нам не хватает способа получить игровое поле, чтобы передать его представлению на отрисовку,
а также метода, выполнив который, можно было бы определить возможен ли ход в текущей позиции,
или нет.

Контроллер, в свою очередь, будет в основном использоваться для обработки пользовательского ввода с клавиатуры,
поэтому сделаем его наследником класса KeyAdapter.

Нам понадобятся приватные поля model и view соответствующих типов и методы getGameTiles и getScore,
возвращающие подходящие свойства модели.

По пунктам:
1. Добавь в класс Model геттер для поля gameTiles.
2. Добавь в класс Model метод canMove возвращающий true в случае, если в текущей позиции
возможно сделать ход так, чтобы состояние игрового поля изменилось. Иначе - false.
3. Сделай класс Controller потомком класса KeyAdapter.
4. Добавь в класс Controller метод getGameTiles вызывающий такой же метод у модели.
5. Добавь в класс Controller метод getScore возвращающий текущий счет (model.score).



2048 (11)

Движение влево мы реализовали, теперь необходимо реализовать методы right, up, down. Уверен, что ты с этим справишься
и без моей помощи, так что дам только одну подсказку.

Что будет, если повернуть двумерный массив на 90 градусов по часовой стрелке, сдвинуть влево, а потом еще
трижды выполнить поворот?



2048 (11)

Итак, ты реализовал сжатие и слияние плиток, что в комбинации дает нам возможность осуществить движение влево.
Отлично! Но нам нужно еще и добавлять новую плитку в случае, если после передвижения игровое поле изменилось.

Давай сделаем так:
1. Изменим метод compressTiles, чтобы он возвращал true в случае, если он вносил изменения во входящий массив,
иначе - false.
2. То же самое сделаем и для метода mergeTiles.
3. Реализуем метод left, который будет для каждой строки массива gameTiles вызывать методы compressTiles
и mergeTiles и добавлять одну плитку с помощью метода addTile в том случае, если это необходимо.
4. Метод left не должен быть приватным, т.к. вызваться он будет, помимо прочего, из класса Controller.



