taskKey="com.javarush.task.task31.task3110.big16"\n\nArchiver (16)

Пришло время что-нибудь удалить из архива. Архив очень хитрая штука, нельзя вот так просто взять и
удалить какой-то элемент внутри него.
Почему? Представь, что мы решили сами придумать свой алгоритм сжатия текста. Посмотрев исходный
текст, мы видим, что в нем часто встречается фраза &quot;быть программистом круто&quot;. Мы можем в месте, где
второй, третий, N-ый раз встречается наша фраза сделать пометку, что тут была фраза, как в строке S
начиная с символа номер K и длиной N, а саму фразу удалить. Когда мы заменим много повторяющихся
фраз, текст заметно сократится, но станет нечитаемым для тех, кто не знаком с нашим алгоритмом сжатия.
Мы же этот текст сможем восстановить (разархивировать). А теперь представь, что нам нужно удалить
часть текста, на которую ссылались сжатые фрагменты. В такой ситуации, весь наш архив перестанет
иметь смысл. Вот почему нельзя просто так удалить часть архива. Это очень примерное описание
варианта архивации, в реальности все намного сложнее.
Поэтому, чтобы что-то удалить из архива, нужно создать новый архив, переписать в него все, кроме
удаляемых файлов, а потом заменить старый архив вновь созданным.
1.	Добавь публичный метод для удаления файлов из архива void removeFiles(List&lt;Path&gt; pathList)
throws Exception в класс ZipFileManager. В pathList будет передаваться список относительных путей на
файлы внутри архива. Он должен:
1.1. Бросать исключение WrongZipFileException, если файл архива не существует.
1.2. Создать временный файл архива в директории по умолчанию с помощью метода createTempFile() класса Files.
1.3. Пройтись по всем файлам оригинального архива, проверить, есть ли текущий файл в списке
на удаление.
- Если файл есть в списке, вывести сообщение, что мы удалили файл с таким-то именем и
перейти к следующему файлу.
- Если файла нет в списке на удаление, переписать его в новый архив
1.4. Заменить оригинальный файл архива временным, в который мы записали нужные файлы.
Это нужно сделать с помощью метода move() класса Files
2.	Добавь публичный метод void removeFile(Path path) throws Exception в класс ZipFileManager,
который будет вызывать метод removeFiles, создавая список из одного элемента. Это можно сделать с помощью
метода singletonList() класса Collections. Посмотри, как он работает.
3.	Реализуй метод execute() класса ZipRemoveCommand, создав объект класса ZipFileManager,
спросив пользователя из какого архива и какой файл будем удалять, и вызвав метод removeFile().
Все остальное, как и в других командах. Исключение PathIsNotFoundException можно не ловить, т.к. метод
removeFile() не должен его кидать.
4.	Запусти программу и проверить, что удаление файла из архива работает.


Требования:
1.	В классе ZipFileManager нужно создать публичный метод void removeFiles(List&lt;Path&gt; pathList) throws Exception.
2.	Метод removeFiles должен бросать исключение WrongZipFileException, если файл архива не существует.
3.	Метод removeFiles должен создавать временный файл архива с помощью метода Files.createTempFile.
4.	Метод removeFiles должен записывать в новый архив все файлы из старого архива, кроме тех, которые в списке на удаление. Затем, заменить старый архив новым.
5.	В классе ZipFileManager нужно создать публичный метод void removeFile(Path path) throws Exception, который будет делегировать свое выполнение методу removeFiles(List&lt;Path&gt; pathList).
6.	Метод execute() в классе ZipRemoveCommand должен получить объект ZipFileManager и удалить из архива файл, считанный с консоли.


Archiver (16)

Пора попробовать что-нибудь распаковать. Для этого добавим публичный метод void extractAll(Path
outputFolder) throws Exception в класс ZipFileManager. Path outputFolder  - это путь, куда мы будем
распаковывать наш архив. У тебя уже большой опыт работы с элементами архива и потоками. Так что, я
дам только подсказки по реализации этого метода, а тебе придется хорошенько подумать, как это все
сделать:
1.	Проверь, есть ли zip файл вообще
2.	Если директория outputFolder не существует, то ее нужно создать, как и все папки, внутри которых
она лежит.
3.	Внутри архива некоторые файлы могут лежат внутри папок, тогда метод getName() элемента
архива ZipEntry, вернет не совсем имя, как может показаться из названия, а относительный путь
внутри архива. Этот относительный путь должен сохраниться и после распаковки, но уже
относительно той директории, куда мы распаковали архив
4.	Реализуй метод execute() класса ZipExtractCommand, по аналогии с таким же методом класса
ZipCreateCommand, сделай такой же блок try-catch, только поменяй сообщения выводимые
пользователю, чтобы он понял, что сейчас мы будем распаковывать архив, и что нужно ввести
полное имя архива и директорию, куда будем распаковывать. Не забудь вызвать метод extractAll
класса ZipFileManager, а не createZip, как это было в ZipCreateCommand
5.	Запускай программу и наслаждайся результатом распаковки

Примечание:
Для получения потоков чтения и записи используй Files.newInputStream(Path path), Files.newOutputStream(Path path).



Archiver (16)

Все готово, чтобы реализовать метод execute() класса ZipContentCommand:
1.	Выведи сообщение &quot;Просмотр содержимого архива.&quot;
2.	Создай объект класса ZipFileManager с помощью метода getZipFileManager()
3.	Выведи сообщение &quot;Содержимое архива:&quot;
4.	Получи список файлов архива с помощью метода getFilesList()
5.	Выведи свойства каждого файла в консоль. Тут нам и пригодится ранее реализованный метод
toString() класса FileProperties
6.	Выведи сообщение &quot;Содержимое архива прочитано.&quot;
7.	Запусти программу и проверь, что команда &quot;просмотреть содержимое архива&quot; работает



Archiver (16)

Продолжим наш путь к получению содержимого файла архива. Напишем метод getFilesList() в классе
ZipFileManager. Он будет возвращать список файлов в архиве, вернее список свойств этих файлов (класс
свойств FileProperties мы уже реализовали). Итак:
1.	Добавь метод List&lt;FileProperties&gt; getFilesList() throws Exception в класс ZipFileManager
2.	Внутри метода проверь является ли содержимое zipFile обычным файлом с помощью
подходящего метода класса Files. Если это не файл, брось исключение WrongZipFileException().
3.	Создай список с элементами типа FileProperties, в него мы будем складывать свойства файлов
4.	Создай входящий поток ZipInputStream, для файла из переменной zipFile. Как и в прошлые разы, оберни его создание
в try-with-resources
5.	Пройдись по всем элементам ZipEntry потока ZipInputStream
6.	Для каждого элемента ZipEntry вычитай его содержимое, иначе у нас не будет информации о его
размере. Нельзя узнать размер файла в архиве, не вычитав его. Это очень легко сделать с
помощью функции copyData, используя временный буфер типа ByteArrayOutputStream.
7.	Получи имя, размер, сжатый размер и метод сжатия элемента архива. Посмотри, что еще можно
узнать о нем.
8.	Создай объект класса FileProperties, используя полученные данные о файле.
9.	Добавь созданный объект из п.8 в список из п.3
10.	После выхода из цикла верни собранную информацию вызвавшему методу.



Archiver (16)

Сегодня мы подготовимся к реализации команды ZipContentCommand. Она будет заниматься получением
содержимого архива. Содержимое архива &ndash; это упакованные файлы и папки, но нам было бы интересно
узнать не только имена объектов архива, но и их размер до и после сжатия, степень сжатия и метод
сжатия.
Создадим класс FileProperties, который будет отвечать за свойства каждого файла в архиве. Свойства &ndash; это
набор, состоящий из: имя файла, размер файла до и после сжатия, метод сжатия.
1.	Создай класс FileProperties
2.	Добавь в него приватные переменные класса:
2.1. Имя String name
2.2. Размер в байтах long size
2.3. Размер после сжатия в байтах long compressedSize
2.4. Метод сжатия int compressionMethod
3.	Добавь гетеры для них
4.	Добавь конструктор FileProperties(String name, long size, long compressedSize, int
compressionMethod)
5.	Добавь метод long getCompressionRatio(), который будет считать степень сжатия по формуле:
100 - ((compressedSize * 100) / size)
6.	Переопрередели метод String toString(), чтобы он возвращал строку по шаблону:
&ldquo;name size Kb (compressedSize Kb) сжатие: compressionRatio%&rdquo;, если размер size больше нуля, иначе он должен
вернуть только имя файла. Нулевой размер может быть, например, у директории. Не забудь
перевести байты в килобайты, а их не столько же, сколько граммов в килограмме, и даже не
столько, сколько блинов у меня на столе&hellip; Хм, похоже мне пора перекусить&hellip;



Archiver (16)

Давай наконец попробуем нормально реализовать метод execute() класса ZipCreateCommand, который
мы добавляли раньше. Для этого нужно:
1.	В начале метода добавить вывод сообщения &quot;Создание архива.&quot; Не забудь, что мы работаем с
консолью через методы класса ConsoleHelper.
2.	Создай новый объект класса ZipFileManager. Т.к. создание этого объекта будет необходимо и
другим командам, вынеси создание в отдельный метод ZipFileManager getZipFileManager() throws
Exception в класс ZipCommand. Этот метод должен:
2.1. Просить пользователя ввести полный путь файла архива
2.2. Считывать введенный путь в переменную типа String
2.3. Используя введенный String формировать путь Path
2.4. Создать объект ZipFileManager, передав в конструктор полученный путь
2.5. Вернуть созданный объект
3.	Попроси пользователя ввести полное имя файла или директории для архивации
4.	Создай путь Path, используя введенную строку
5.	У объекта класса ZipFileManager вызови метод createZip(), передав в него путь из п.4
6.	Выведи в консоль сообщение &quot;Архив создан.&quot;
7.	Оберни содержимое метода execute() класса ZipCreateCommand в блок try-catch и отлавливай
исключение типа PathIsNotFoundException. Если оно произошло, выведи сообщение &quot;Вы неверно
указали имя файла или директории.&quot;
8.	Запусти программу и проверь, что команда &quot;упаковать файлы в архив&quot; работает



