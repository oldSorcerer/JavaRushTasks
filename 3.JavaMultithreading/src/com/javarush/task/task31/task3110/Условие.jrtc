taskKey="com.javarush.task.task31.task3110.big17"\n\nArchiver (17)

Осталась ерунда. Добавить добавление файла в архив. Звучит подозрительно, но именно этим мы и
займемся. Добавление файлов похоже на удаление, мы создаем временный файл архив, переписываем в
него все содержимое старого архива и добавляем новые файлы. Потом заменяем старый файл архива
новым.
1.	Добавь публичный метод void addFiles(List&lt;Path&gt; absolutePathList) throws Exception в класс
ZipFileManager, где absolutePathList &ndash; список абсолютных путей добавляемых файлов. Этот метод
должен:
1.1. Как обычно, бросать исключение WrongZipFileException, если файл архива не существует
1.2. Создать временный файл архива
1.3. Пройти по всем файлам оригинального архива, переписать каждый файл в новый архив,
добавить имя переписанного файла в какой-нибудь локальный список.
1.4. Пройтись по списку добавляемых файлов.
1.5. Для каждого файла проверить, есть ли он на диске и является ли он обычным файлом,
если что-то не так, кинь исключение PathIsNotFoundException()
1.6. Проверить, есть ли добавляемый файл уже в архиве (используй список из п.1.3). Такое
возможно, если пользователь уже когда-то добавлял его.
- Если файла нет в списке, добавь его в новый архив, выведи сообщение, что такой-то файл
добавлен в архив
- Если файл есть в списке, просто сообщи пользователю, что такой файл уже есть в архиве
1.7. Заменить оригинальный файл архива временным, в котором уже есть добавленные
файлы.
2.	Добавь публичный метод void addFile(Path absolutePath) throws Exception в класс ZipFileManager,
реализуй его с помощью вызова метода addFiles(), аналогично тому, как мы это делали для
удаления файла.
3.	Реализуй метод execute() класса ZipAddCommand: все как обычно, но не забудь спросить у
пользователя в какой архив и какой файл он хочет добавить, обработай исключение
PathIsNotFoundException, которое может кинуть метод addFile().
4.	Запусти программу и проверить, что добавление файла теперь работает.


Требования:
1.	В классе ZipFileManager нужно создать публичный метод void addFiles(List&lt;Path&gt; absolutePathList) throws Exception.
2.	Метод addFiles должен бросать исключение WrongZipFileException, если файл архива не существует.
3.	Метод addFiles должен создавать временный файл архива с помощью метода Files.createTempFile.
4.	Метод addFiles должен проходить по списку добавляемых файлов и бросить PathIsNotFoundException, если какой-то файл не существует.
5.	Метод addFiles должен записывать в новый архив новые файлы и все файлы из старого архива. Затем, заменить старый архив новым.
6.	В классе ZipFileManager нужно создать публичный метод void addFile(Path absolutePath) throws Exception, который будет делегировать свое выполнение методу addFiles(List&lt;Path&gt; absolutePathList).
7.	Метод execute() в классе ZipAddCommand должен получить объект ZipFileManager и добавить в архив файл, считанный с консоли.


Archiver (17)

Пришло время что-нибудь удалить из архива. Архив очень хитрая штука, нельзя вот так просто взять и
удалить какой-то элемент внутри него.
Почему? Представь, что мы решили сами придумать свой алгоритм сжатия текста. Посмотрев исходный
текст, мы видим, что в нем часто встречается фраза &quot;быть программистом круто&quot;. Мы можем в месте, где
второй, третий, N-ый раз встречается наша фраза сделать пометку, что тут была фраза, как в строке S
начиная с символа номер K и длиной N, а саму фразу удалить. Когда мы заменим много повторяющихся
фраз, текст заметно сократится, но станет нечитаемым для тех, кто не знаком с нашим алгоритмом сжатия.
Мы же этот текст сможем восстановить (разархивировать). А теперь представь, что нам нужно удалить
часть текста, на которую ссылались сжатые фрагменты. В такой ситуации, весь наш архив перестанет
иметь смысл. Вот почему нельзя просто так удалить часть архива. Это очень примерное описание
варианта архивации, в реальности все намного сложнее.
Поэтому, чтобы что-то удалить из архива, нужно создать новый архив, переписать в него все, кроме
удаляемых файлов, а потом заменить старый архив вновь созданным.
1.	Добавь публичный метод для удаления файлов из архива void removeFiles(List&lt;Path&gt; pathList)
throws Exception в класс ZipFileManager. В pathList будет передаваться список относительных путей на
файлы внутри архива. Он должен:
1.1. Бросать исключение WrongZipFileException, если файл архива не существует.
1.2. Создать временный файл архива в директории по умолчанию с помощью метода createTempFile() класса Files.
1.3. Пройтись по всем файлам оригинального архива, проверить, есть ли текущий файл в списке
на удаление.
- Если файл есть в списке, вывести сообщение, что мы удалили файл с таким-то именем и
перейти к следующему файлу.
- Если файла нет в списке на удаление, переписать его в новый архив
1.4. Заменить оригинальный файл архива временным, в который мы записали нужные файлы.
Это нужно сделать с помощью метода move() класса Files
2.	Добавь публичный метод void removeFile(Path path) throws Exception в класс ZipFileManager,
который будет вызывать метод removeFiles, создавая список из одного элемента. Это можно сделать с помощью
метода singletonList() класса Collections. Посмотри, как он работает.
3.	Реализуй метод execute() класса ZipRemoveCommand, создав объект класса ZipFileManager,
спросив пользователя из какого архива и какой файл будем удалять, и вызвав метод removeFile().
Все остальное, как и в других командах. Исключение PathIsNotFoundException можно не ловить, т.к. метод
removeFile() не должен его кидать.
4.	Запусти программу и проверить, что удаление файла из архива работает.



Archiver (17)

Пора попробовать что-нибудь распаковать. Для этого добавим публичный метод void extractAll(Path
outputFolder) throws Exception в класс ZipFileManager. Path outputFolder  - это путь, куда мы будем
распаковывать наш архив. У тебя уже большой опыт работы с элементами архива и потоками. Так что, я
дам только подсказки по реализации этого метода, а тебе придется хорошенько подумать, как это все
сделать:
1.	Проверь, есть ли zip файл вообще
2.	Если директория outputFolder не существует, то ее нужно создать, как и все папки, внутри которых
она лежит.
3.	Внутри архива некоторые файлы могут лежат внутри папок, тогда метод getName() элемента
архива ZipEntry, вернет не совсем имя, как может показаться из названия, а относительный путь
внутри архива. Этот относительный путь должен сохраниться и после распаковки, но уже
относительно той директории, куда мы распаковали архив
4.	Реализуй метод execute() класса ZipExtractCommand, по аналогии с таким же методом класса
ZipCreateCommand, сделай такой же блок try-catch, только поменяй сообщения выводимые
пользователю, чтобы он понял, что сейчас мы будем распаковывать архив, и что нужно ввести
полное имя архива и директорию, куда будем распаковывать. Не забудь вызвать метод extractAll
класса ZipFileManager, а не createZip, как это было в ZipCreateCommand
5.	Запускай программу и наслаждайся результатом распаковки

Примечание:
Для получения потоков чтения и записи используй Files.newInputStream(Path path), Files.newOutputStream(Path path).



Archiver (17)

Все готово, чтобы реализовать метод execute() класса ZipContentCommand:
1.	Выведи сообщение &quot;Просмотр содержимого архива.&quot;
2.	Создай объект класса ZipFileManager с помощью метода getZipFileManager()
3.	Выведи сообщение &quot;Содержимое архива:&quot;
4.	Получи список файлов архива с помощью метода getFilesList()
5.	Выведи свойства каждого файла в консоль. Тут нам и пригодится ранее реализованный метод
toString() класса FileProperties
6.	Выведи сообщение &quot;Содержимое архива прочитано.&quot;
7.	Запусти программу и проверь, что команда &quot;просмотреть содержимое архива&quot; работает



Archiver (17)

Продолжим наш путь к получению содержимого файла архива. Напишем метод getFilesList() в классе
ZipFileManager. Он будет возвращать список файлов в архиве, вернее список свойств этих файлов (класс
свойств FileProperties мы уже реализовали). Итак:
1.	Добавь метод List&lt;FileProperties&gt; getFilesList() throws Exception в класс ZipFileManager
2.	Внутри метода проверь является ли содержимое zipFile обычным файлом с помощью
подходящего метода класса Files. Если это не файл, брось исключение WrongZipFileException().
3.	Создай список с элементами типа FileProperties, в него мы будем складывать свойства файлов
4.	Создай входящий поток ZipInputStream, для файла из переменной zipFile. Как и в прошлые разы, оберни его создание
в try-with-resources
5.	Пройдись по всем элементам ZipEntry потока ZipInputStream
6.	Для каждого элемента ZipEntry вычитай его содержимое, иначе у нас не будет информации о его
размере. Нельзя узнать размер файла в архиве, не вычитав его. Это очень легко сделать с
помощью функции copyData, используя временный буфер типа ByteArrayOutputStream.
7.	Получи имя, размер, сжатый размер и метод сжатия элемента архива. Посмотри, что еще можно
узнать о нем.
8.	Создай объект класса FileProperties, используя полученные данные о файле.
9.	Добавь созданный объект из п.8 в список из п.3
10.	После выхода из цикла верни собранную информацию вызвавшему методу.



Archiver (17)

Сегодня мы подготовимся к реализации команды ZipContentCommand. Она будет заниматься получением
содержимого архива. Содержимое архива &ndash; это упакованные файлы и папки, но нам было бы интересно
узнать не только имена объектов архива, но и их размер до и после сжатия, степень сжатия и метод
сжатия.
Создадим класс FileProperties, который будет отвечать за свойства каждого файла в архиве. Свойства &ndash; это
набор, состоящий из: имя файла, размер файла до и после сжатия, метод сжатия.
1.	Создай класс FileProperties
2.	Добавь в него приватные переменные класса:
2.1. Имя String name
2.2. Размер в байтах long size
2.3. Размер после сжатия в байтах long compressedSize
2.4. Метод сжатия int compressionMethod
3.	Добавь гетеры для них
4.	Добавь конструктор FileProperties(String name, long size, long compressedSize, int
compressionMethod)
5.	Добавь метод long getCompressionRatio(), который будет считать степень сжатия по формуле:
100 - ((compressedSize * 100) / size)
6.	Переопрередели метод String toString(), чтобы он возвращал строку по шаблону:
&ldquo;name size Kb (compressedSize Kb) сжатие: compressionRatio%&rdquo;, если размер size больше нуля, иначе он должен
вернуть только имя файла. Нулевой размер может быть, например, у директории. Не забудь
перевести байты в килобайты, а их не столько же, сколько граммов в килограмме, и даже не
столько, сколько блинов у меня на столе&hellip; Хм, похоже мне пора перекусить&hellip;



