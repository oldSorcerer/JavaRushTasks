taskKey="com.javarush.task.task31.task3110.big15"\n\nArchiver (15)

Пора попробовать что-нибудь распаковать. Для этого добавим публичный метод void extractAll(Path
outputFolder) throws Exception в класс ZipFileManager. Path outputFolder  - это путь, куда мы будем
распаковывать наш архив. У тебя уже большой опыт работы с элементами архива и потоками. Так что, я
дам только подсказки по реализации этого метода, а тебе придется хорошенько подумать, как это все
сделать:
1.	Проверь, есть ли zip файл вообще
2.	Если директория outputFolder не существует, то ее нужно создать, как и все папки, внутри которых
она лежит.
3.	Внутри архива некоторые файлы могут лежат внутри папок, тогда метод getName() элемента
архива ZipEntry, вернет не совсем имя, как может показаться из названия, а относительный путь
внутри архива. Этот относительный путь должен сохраниться и после распаковки, но уже
относительно той директории, куда мы распаковали архив
4.	Реализуй метод execute() класса ZipExtractCommand, по аналогии с таким же методом класса
ZipCreateCommand, сделай такой же блок try-catch, только поменяй сообщения выводимые
пользователю, чтобы он понял, что сейчас мы будем распаковывать архив, и что нужно ввести
полное имя архива и директорию, куда будем распаковывать. Не забудь вызвать метод extractAll
класса ZipFileManager, а не createZip, как это было в ZipCreateCommand
5.	Запускай программу и наслаждайся результатом распаковки

Примечание:
Для получения потоков чтения и записи используй Files.newInputStream(Path path), Files.newOutputStream(Path path).


Требования:
1.	В классе ZipFileManager нужно создать публичный метод void extractAll(Path outputFolder) throws Exception.
2.	Метод extractAll(Path outputFolder) должен бросать исключение WrongZipFileException, если файл архива не существует.
3.	Метод extractAll(Path outputFolder) должен создавать директорию outputFolder, если она не существует.
4.	Метод extractAll(Path outputFolder) должен распаковывать все файлы из архива в директорию outputFolder.
5.	Метод execute() в классе ZipExtractCommand должен получать объект ZipFileManager и разархивировать файлы в указанную пользователем директорию.


Archiver (15)

Все готово, чтобы реализовать метод execute() класса ZipContentCommand:
1.	Выведи сообщение &quot;Просмотр содержимого архива.&quot;
2.	Создай объект класса ZipFileManager с помощью метода getZipFileManager()
3.	Выведи сообщение &quot;Содержимое архива:&quot;
4.	Получи список файлов архива с помощью метода getFilesList()
5.	Выведи свойства каждого файла в консоль. Тут нам и пригодится ранее реализованный метод
toString() класса FileProperties
6.	Выведи сообщение &quot;Содержимое архива прочитано.&quot;
7.	Запусти программу и проверь, что команда &quot;просмотреть содержимое архива&quot; работает



Archiver (15)

Продолжим наш путь к получению содержимого файла архива. Напишем метод getFilesList() в классе
ZipFileManager. Он будет возвращать список файлов в архиве, вернее список свойств этих файлов (класс
свойств FileProperties мы уже реализовали). Итак:
1.	Добавь метод List&lt;FileProperties&gt; getFilesList() throws Exception в класс ZipFileManager
2.	Внутри метода проверь является ли содержимое zipFile обычным файлом с помощью
подходящего метода класса Files. Если это не файл, брось исключение WrongZipFileException().
3.	Создай список с элементами типа FileProperties, в него мы будем складывать свойства файлов
4.	Создай входящий поток ZipInputStream, для файла из переменной zipFile. Как и в прошлые разы, оберни его создание
в try-with-resources
5.	Пройдись по всем элементам ZipEntry потока ZipInputStream
6.	Для каждого элемента ZipEntry вычитай его содержимое, иначе у нас не будет информации о его
размере. Нельзя узнать размер файла в архиве, не вычитав его. Это очень легко сделать с
помощью функции copyData, используя временный буфер типа ByteArrayOutputStream.
7.	Получи имя, размер, сжатый размер и метод сжатия элемента архива. Посмотри, что еще можно
узнать о нем.
8.	Создай объект класса FileProperties, используя полученные данные о файле.
9.	Добавь созданный объект из п.8 в список из п.3
10.	После выхода из цикла верни собранную информацию вызвавшему методу.



Archiver (15)

Сегодня мы подготовимся к реализации команды ZipContentCommand. Она будет заниматься получением
содержимого архива. Содержимое архива &ndash; это упакованные файлы и папки, но нам было бы интересно
узнать не только имена объектов архива, но и их размер до и после сжатия, степень сжатия и метод
сжатия.
Создадим класс FileProperties, который будет отвечать за свойства каждого файла в архиве. Свойства &ndash; это
набор, состоящий из: имя файла, размер файла до и после сжатия, метод сжатия.
1.	Создай класс FileProperties
2.	Добавь в него приватные переменные класса:
2.1. Имя String name
2.2. Размер в байтах long size
2.3. Размер после сжатия в байтах long compressedSize
2.4. Метод сжатия int compressionMethod
3.	Добавь гетеры для них
4.	Добавь конструктор FileProperties(String name, long size, long compressedSize, int
compressionMethod)
5.	Добавь метод long getCompressionRatio(), который будет считать степень сжатия по формуле:
100 - ((compressedSize * 100) / size)
6.	Переопрередели метод String toString(), чтобы он возвращал строку по шаблону:
&ldquo;name size Kb (compressedSize Kb) сжатие: compressionRatio%&rdquo;, если размер size больше нуля, иначе он должен
вернуть только имя файла. Нулевой размер может быть, например, у директории. Не забудь
перевести байты в килобайты, а их не столько же, сколько граммов в килограмме, и даже не
столько, сколько блинов у меня на столе&hellip; Хм, похоже мне пора перекусить&hellip;



Archiver (15)

Давай наконец попробуем нормально реализовать метод execute() класса ZipCreateCommand, который
мы добавляли раньше. Для этого нужно:
1.	В начале метода добавить вывод сообщения &quot;Создание архива.&quot; Не забудь, что мы работаем с
консолью через методы класса ConsoleHelper.
2.	Создай новый объект класса ZipFileManager. Т.к. создание этого объекта будет необходимо и
другим командам, вынеси создание в отдельный метод ZipFileManager getZipFileManager() throws
Exception в класс ZipCommand. Этот метод должен:
2.1. Просить пользователя ввести полный путь файла архива
2.2. Считывать введенный путь в переменную типа String
2.3. Используя введенный String формировать путь Path
2.4. Создать объект ZipFileManager, передав в конструктор полученный путь
2.5. Вернуть созданный объект
3.	Попроси пользователя ввести полное имя файла или директории для архивации
4.	Создай путь Path, используя введенную строку
5.	У объекта класса ZipFileManager вызови метод createZip(), передав в него путь из п.4
6.	Выведи в консоль сообщение &quot;Архив создан.&quot;
7.	Оберни содержимое метода execute() класса ZipCreateCommand в блок try-catch и отлавливай
исключение типа PathIsNotFoundException. Если оно произошло, выведи сообщение &quot;Вы неверно
указали имя файла или директории.&quot;
8.	Запусти программу и проверь, что команда &quot;упаковать файлы в архив&quot; работает



Archiver (15)

Пришло время отрефакторить класс ZipFileManager. В методе createZip есть код, который нам также
понадобится в методах, которые будут добавлять или удалять файл в архив, распаковывать его и т.д. Эти
методы мы будем реализовывать позже, но уже сейчас можем вынести общие части кода в отдельные
методы.
Кроме того, метод createZip мог создавать архив только из одного файла, а хотелось бы уметь
архивировать всю папку целиком. Создавать отдельный метод для этого не будем, т.к. в createZip(Path
source) можно передавать и директорию и обычный файл.
Задания на сегодня:
1.	Реализуй приватный метод void addNewZipEntry(ZipOutputStream zipOutputStream, Path filePath,
Path fileName) throws Exception в классе ZipFileManager. Он должен:
1.1. Создавать InputStream, для файла с именем fileName, расположенным в
директории filePath
1.2. Создавать новый элемент архива ZipEntry, в качестве имени используй fileName,
преобразовав его в String
1.3. Добавить в переданный zipOutputStream новый элемент архива ZipEntry (из п.1.2)
1.4. Копировать данные из InputStream (из п.1.1) в переданный zipOutputStream
1.5. Закрывать в zipOutputStream элемент архива ZipEntry (из п.1.2)
1.6. Закрывать InputStream, сделай это с помощью try-with-resources
2.	Замени часть кода метода createZip вызовом нового метода addNewZipEntry(). Передай значение
source.getParent() в параметр filePath, а source.getFileName() в filename.
3.	Реализуй приватный метод void copyData(InputStream in, OutputStream out) throws Exception. Он
должен читать данные из in и записывать в out, пока не вычитает все.
4.	Замени часть кода метода addNewZipEntry на вызов метода copyData
5.	Вернемся к createZip:
5.1. В начале метода проверь, что существует директория (zipFile.getParent()), в которой мы
будем создавать zipFile, если ее нет, то создай ее.
5.2. Если source является обычным файлом (для проверки используй Files.isRegularFile), то оставим просто вызов
addNewZipEntry
5.3. Если source является директорией (для проверки используй Files.isDirectory), то:
5.3.1.	Создай объект класса файловый менеджер FileManager, в конструктор передадим
source
5.3.2.	Получи список файлов у файлового менеджера, сохраним его в переменную
fileNames
5.3.3.	Для всех элементов fileNames, вызови метод addNewZipEntry(zipOutputStream,
source, fileName)
5.4. Если source не является ни папкой, ни файлом, то кинь исключение
PathIsNotFoundException.



