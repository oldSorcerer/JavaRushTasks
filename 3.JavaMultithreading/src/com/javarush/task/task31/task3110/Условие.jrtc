taskKey="com.javarush.task.task31.task3110.big10"\n\nArchiver (10)

Пришло время отрефакторить класс ZipFileManager. В методе createZip есть код, который нам также
понадобится в методах, которые будут добавлять или удалять файл в архив, распаковывать его и т.д. Эти
методы мы будем реализовывать позже, но уже сейчас можем вынести общие части кода в отдельные
методы.
Кроме того, метод createZip мог создавать архив только из одного файла, а хотелось бы уметь
архивировать всю папку целиком. Создавать отдельный метод для этого не будем, т.к. в createZip(Path
source) можно передавать и директорию и обычный файл.
Задания на сегодня:
1.	Реализуй приватный метод void addNewZipEntry(ZipOutputStream zipOutputStream, Path filePath,
Path fileName) throws Exception в классе ZipFileManager. Он должен:
1.1. Создавать InputStream, для файла с именем fileName, расположенным в
директории filePath
1.2. Создавать новый элемент архива ZipEntry, в качестве имени используй fileName,
преобразовав его в String
1.3. Добавить в переданный zipOutputStream новый элемент архива ZipEntry (из п.1.2)
1.4. Копировать данные из InputStream (из п.1.1) в переданный zipOutputStream
1.5. Закрывать в zipOutputStream элемент архива ZipEntry (из п.1.2)
1.6. Закрывать InputStream, сделай это с помощью try-with-resources
2.	Замени часть кода метода createZip вызовом нового метода addNewZipEntry(). Передай значение
source.getParent() в параметр filePath, а source.getFileName() в filename.
3.	Реализуй приватный метод void copyData(InputStream in, OutputStream out) throws Exception. Он
должен читать данные из in и записывать в out, пока не вычитает все.
4.	Замени часть кода метода addNewZipEntry на вызов метода copyData
5.	Вернемся к createZip:
5.1. В начале метода проверь, что существует директория (zipFile.getParent()), в которой мы
будем создавать zipFile, если ее нет, то создай ее.
5.2. Если source является обычным файлом (для проверки используй Files.isRegularFile), то оставим просто вызов
addNewZipEntry
5.3. Если source является директорией (для проверки используй Files.isDirectory), то:
5.3.1.	Создай объект класса файловый менеджер FileManager, в конструктор передадим
source
5.3.2.	Получи список файлов у файлового менеджера, сохраним его в переменную
fileNames
5.3.3.	Для всех элементов fileNames, вызови метод addNewZipEntry(zipOutputStream,
source, fileName)
5.4. Если source не является ни папкой, ни файлом, то кинь исключение
PathIsNotFoundException.


Требования:
1.	В классе ZipFileManager добавь приватный метод void addNewZipEntry(ZipOutputStream zipOutputStream, Path filePath, Path fileName) throws Exception.
2.	Метод addNewZipEntry должен быть реализован следуя описанию в задании.
3.	Замени часть кода метода createZip вызовом нового метода addNewZipEntry.
4.	В классе ZipFileManager добавь приватный метод void copyData(InputStream in, OutputStream out) throws Exception.
5.	Метод copyData должен читать данные из in и записывать в out, пока не вычитает все байты.
6.	Замени часть кода метода addNewZipEntry вызовом нового метода copyData.
7.	Метод createZip в классе ZipFileManager должен быть доработан следуя описанию в задании.


Archiver (10)

Теперь займемся другой, не менее важной частью нашего архиватора. Очень часто пользователь хочет
создать архив не из одного файла, а из целой папки. Тогда архивация сводится к поочередному
добавлению элемента ZipEntry для каждого файла в архив.
Нам нужно написать класс FileManager для получения списка всех файлов в какой-то папке. У него должен
быть конструктор, который будет принимать путь Path rootPath, указывающий на корень (папку, файлы в
которой нас интересуют) и метод List&lt;Path&gt; getFileList(), который должен возвращать список
относительных путей всех файлов, которые находятся по пути rootPath, включая файлы в подпапках.
Директория, в которой будем искать, может задаваться только один раз в конструкторе. Поэтому, прямо в
конструкторе мы сразу можем сформировать список файлов (их относительных путей), сохранив его в
переменную класса List&lt;Path&gt; fileList.
Осталось только решить, как нам собрать все файлы, даже те, которые могут быть в папке, которая в папке,
которая в папке, которая в интересующей нас папке. Фух, чуть не вошел рекурсию. Хотя нам-то она и
поможет! Сделаем метод collectFileList(Path path), который будет складывать в переменную класса fileList
все файлы, обнаруженные внутри переданного пути path, вызывая сам себя для всех объектов, в
обнаруженных директориях.
1.	Создай класс FileManager с конструктором FileManager(Path rootPath) throws IOException
2.	Объяви и проинициализируй приватные переменные класса:
2.1. Path rootPath &ndash; корневой путь директории, файлы которой нас интересуют
2.2. List&lt;Path&gt; fileList &ndash; список относительных путей файлов внутри rootPath
3.	Создай геттер для fileList
4.	Реализуй метод void collectFileList(Path path) throws IOException, который должен:
4.1. Проверить, если переданный путь path является обычным файлом (используй метод
Files.isRegularFile), то получить его относительный путь относительно rootPath
и добавить его в список fileList.
4.2. Если переданный путь path, является директорией (узнать это поможет метод
Files.isDirectory), то пройтись по всему содержимому директории и вызвать
collectFileList(Path path), передав в path обнаруженные элементы.
Пройтись по всему содержимому директории можно предварительно получив DirectoryStream с помощью метода
newDirectoryStream класса Files. Не забудь закрыть созданный DirectoryStream.
5.	Добавь вызов метода collectFileList(rootPath) в конструкторе FileManager.
6.	Примени все свои знания об инкапсуляции к этому классу.
Выполняя это задание, ты написал алгоритм, который обходит дерево файлов. Но в Java есть специальный интерфейс
FileVisitor для этих целей. Очень рекомендую разобраться как им пользоваться.



Archiver (10)

Чтобы узнать какую команду сейчас хочет выполнить пользователь, добавим метод Operation
askOperation() в класс Archiver. Этот метод должен вывести в консоль список доступных команд и
попросить выбрать одну из них. Для удобства будем просить ввести номер команды, где номер &ndash; это
порядковый номер команды в enum Operation. Получить порядковый номер значения в enum&rsquo;е можно с
помощью метода ordinal().
Теперь все готово чтобы переписать main, используя последние достижения науки и техники, а именно
класс CommandExecutor и метод askOperation().
1.	Добавь публичный статический метод Operation askOperation() throws IOException в класс Archiver.
Он должен:
1.1. Использовать методы класса ConsoleHelper
1.2. Запрашивать у пользователя номер операции, которую он хочет совершить. Подсказка:
чтобы вывести номер операции &laquo;Создать архив&raquo;, используй: Operation.CREATE.ordinal()
1.3. Возвращать выбранную операцию.
Пример вывода метода askOperation():
Выберите операцию:
0 - упаковать файлы в архив
1 - добавить файл в архив
2 - удалить файл из архива
3 - распаковать архив
4 - просмотреть содержимое архива
5 &ndash; выход
2.	Перепиши метод main():
2.1. Объяви локальную переменную типа Operation
2.2. В цикле запрашивай новое значение для переменной п.2.1. с помощью метода askOperation() и
вызывай выполнение операции с помощью CommandExecutor.execute()
2.3. Обеспечь выход из цикла, если пользователь выбрал операцию Operation.EXIT
2.4. Оберни вызов askOperation() и execute(operation) в блок try-catch. Если произойдет
исключение WrongZipFileException выведи сообщение &quot;Вы не выбрали файл архива или
выбрали неверный файл.&quot; с помощью ConsoleHelper, при любых других исключениях
выводи &quot;Произошла ошибка. Проверьте введенные данные.&quot;.
2.5. Проследи, чтобы программа продолжила свою работу (перешла на новый шаг цикла),
после обработки исключений.
3.	Запусти программу и проверь, что команда &ldquo;выход&rdquo; работает.



Archiver (10)

Мы много всего сделали и можно немного передохнуть.
Создадим, пакет exception и добавим в него два класса PathIsNotFoundException и WrongZipFileException.
Исключение PathIsNotFoundException будем кидать, если не сможем найти путь, в который нужно
распаковать архив, или путь к файлу, который хотим запаковать, или любой другой путь. Исключение
WrongZipFileException будем кидать, если будет попытка сделать что-нибудь с архивом, который не
существует.
1.	Создай пакет exception
2.	Добавь в него класс PathIsNotFoundException унаследованный от Exception
3.	Добавь класс WrongZipFileException, также унаследованный от Exception



Archiver (10)

Представь, что пользователь сообщает нам с помощью переменной Operation operation, что он хочет
сделать. Тогда мы должны проверить значение этой переменной, создать объект соответствующего
класса команды и вызвать у него метод execute(). Чтобы не создавать объект класса нужной команды
каждый раз, его нужно где-то хранить. Создадим для этих целей класс CommandExecutor, пусть у него
будет открытым только один публичный статический метод execute(Operation operation), который найдет
нужную команду и вызовет у нее метод execute.
1.	Создай класс CommandExecutor. Он должен быть в корне задачи, не стоит добавлять его в пакет command
2.	Запрети явный вызов конструктора этого класса
3.	Добавь в класс приватное статическое константное хранилище команд Map&lt;Operation, Command&gt;
ALL_KNOWN_COMMANDS_MAP = new HashMap&lt;&gt;()
4.	Добавь в хранилище ALL_KNOWN_COMMANDS_MAP все значения Operation так, чтобы каждому значению соответствовала правильная команда.
Поскольку хранилище создается один раз, то добавление значений лучше сделать в статическом блоке инициализации.
5.	Реализуй публичный статический метод execute(Operation operation) throws Exception, который
должен брать нужную команду из ALL_KNOWN_COMMANDS_MAP и вызывать у нее метод execute.
Догадался ты или нет, но ты только что реализовал паттерн Команда!



Archiver (10)

Разделим команды на два типа: те, которые работают непосредственно с архивом и вспомогательные
(например EXIT). Все команды первого типа, будут иметь общий функционал, его удобно вынести в какой-
то их общий базовый класс. Назовем этот класс ZipCommand. Он, как и все классы команд, должен
реализовывать интерфейс Command. Все команды, которые работают с архивом, должны быть
унаследованы от класса ZipCommand. Мы не будем создавать объекты класса ZipCommand, поэтому
сделаем его абстрактным.
1.	Создай абстрактный класс ZipCommand, реализующий интерфейс Command
2.	Создай по одному классу для каждой команды. Все перечисленные команды должны быть
унаследованы от ZipCommand и содержать пустую реализацию метода execute(), его реализацию
мы будем писать для каждой команды отдельно по мере реализации нашего архиватора.
2.1. Команда создания архива (упаковки файлов в архив) &ndash; class ZipCreateCommand
2.2. Команда просмотра содержимого архива &ndash; class ZipContentCommand
2.3. Команда распаковки архива &ndash; class ZipExtractCommand
2.4. Команда добавления файла в архив &ndash; class ZipAddCommand
2.5. Команда удаления файла из архива &ndash; class ZipRemoveCommand



