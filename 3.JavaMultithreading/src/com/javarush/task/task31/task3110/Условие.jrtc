taskKey="com.javarush.task.task31.task3110.big18"\n\nArchiver (18)

Ты отличный ученик, я немного подправил твой код, можешь использовать этот архиватор для архивации
в повседневной жизни. Если будет время и желание, попробуй добавить операцию изменения степени
сжатия архива!


Требования:
1.	Архиватор готов.


Archiver (18)

Осталась ерунда. Добавить добавление файла в архив. Звучит подозрительно, но именно этим мы и
займемся. Добавление файлов похоже на удаление, мы создаем временный файл архив, переписываем в
него все содержимое старого архива и добавляем новые файлы. Потом заменяем старый файл архива
новым.
1.	Добавь публичный метод void addFiles(List&lt;Path&gt; absolutePathList) throws Exception в класс
ZipFileManager, где absolutePathList &ndash; список абсолютных путей добавляемых файлов. Этот метод
должен:
1.1. Как обычно, бросать исключение WrongZipFileException, если файл архива не существует
1.2. Создать временный файл архива
1.3. Пройти по всем файлам оригинального архива, переписать каждый файл в новый архив,
добавить имя переписанного файла в какой-нибудь локальный список.
1.4. Пройтись по списку добавляемых файлов.
1.5. Для каждого файла проверить, есть ли он на диске и является ли он обычным файлом,
если что-то не так, кинь исключение PathIsNotFoundException()
1.6. Проверить, есть ли добавляемый файл уже в архиве (используй список из п.1.3). Такое
возможно, если пользователь уже когда-то добавлял его.
- Если файла нет в списке, добавь его в новый архив, выведи сообщение, что такой-то файл
добавлен в архив
- Если файл есть в списке, просто сообщи пользователю, что такой файл уже есть в архиве
1.7. Заменить оригинальный файл архива временным, в котором уже есть добавленные
файлы.
2.	Добавь публичный метод void addFile(Path absolutePath) throws Exception в класс ZipFileManager,
реализуй его с помощью вызова метода addFiles(), аналогично тому, как мы это делали для
удаления файла.
3.	Реализуй метод execute() класса ZipAddCommand: все как обычно, но не забудь спросить у
пользователя в какой архив и какой файл он хочет добавить, обработай исключение
PathIsNotFoundException, которое может кинуть метод addFile().
4.	Запусти программу и проверить, что добавление файла теперь работает.



Archiver (18)

Пришло время что-нибудь удалить из архива. Архив очень хитрая штука, нельзя вот так просто взять и
удалить какой-то элемент внутри него.
Почему? Представь, что мы решили сами придумать свой алгоритм сжатия текста. Посмотрев исходный
текст, мы видим, что в нем часто встречается фраза &quot;быть программистом круто&quot;. Мы можем в месте, где
второй, третий, N-ый раз встречается наша фраза сделать пометку, что тут была фраза, как в строке S
начиная с символа номер K и длиной N, а саму фразу удалить. Когда мы заменим много повторяющихся
фраз, текст заметно сократится, но станет нечитаемым для тех, кто не знаком с нашим алгоритмом сжатия.
Мы же этот текст сможем восстановить (разархивировать). А теперь представь, что нам нужно удалить
часть текста, на которую ссылались сжатые фрагменты. В такой ситуации, весь наш архив перестанет
иметь смысл. Вот почему нельзя просто так удалить часть архива. Это очень примерное описание
варианта архивации, в реальности все намного сложнее.
Поэтому, чтобы что-то удалить из архива, нужно создать новый архив, переписать в него все, кроме
удаляемых файлов, а потом заменить старый архив вновь созданным.
1.	Добавь публичный метод для удаления файлов из архива void removeFiles(List&lt;Path&gt; pathList)
throws Exception в класс ZipFileManager. В pathList будет передаваться список относительных путей на
файлы внутри архива. Он должен:
1.1. Бросать исключение WrongZipFileException, если файл архива не существует.
1.2. Создать временный файл архива в директории по умолчанию с помощью метода createTempFile() класса Files.
1.3. Пройтись по всем файлам оригинального архива, проверить, есть ли текущий файл в списке
на удаление.
- Если файл есть в списке, вывести сообщение, что мы удалили файл с таким-то именем и
перейти к следующему файлу.
- Если файла нет в списке на удаление, переписать его в новый архив
1.4. Заменить оригинальный файл архива временным, в который мы записали нужные файлы.
Это нужно сделать с помощью метода move() класса Files
2.	Добавь публичный метод void removeFile(Path path) throws Exception в класс ZipFileManager,
который будет вызывать метод removeFiles, создавая список из одного элемента. Это можно сделать с помощью
метода singletonList() класса Collections. Посмотри, как он работает.
3.	Реализуй метод execute() класса ZipRemoveCommand, создав объект класса ZipFileManager,
спросив пользователя из какого архива и какой файл будем удалять, и вызвав метод removeFile().
Все остальное, как и в других командах. Исключение PathIsNotFoundException можно не ловить, т.к. метод
removeFile() не должен его кидать.
4.	Запусти программу и проверить, что удаление файла из архива работает.



Archiver (18)

Пора попробовать что-нибудь распаковать. Для этого добавим публичный метод void extractAll(Path
outputFolder) throws Exception в класс ZipFileManager. Path outputFolder  - это путь, куда мы будем
распаковывать наш архив. У тебя уже большой опыт работы с элементами архива и потоками. Так что, я
дам только подсказки по реализации этого метода, а тебе придется хорошенько подумать, как это все
сделать:
1.	Проверь, есть ли zip файл вообще
2.	Если директория outputFolder не существует, то ее нужно создать, как и все папки, внутри которых
она лежит.
3.	Внутри архива некоторые файлы могут лежат внутри папок, тогда метод getName() элемента
архива ZipEntry, вернет не совсем имя, как может показаться из названия, а относительный путь
внутри архива. Этот относительный путь должен сохраниться и после распаковки, но уже
относительно той директории, куда мы распаковали архив
4.	Реализуй метод execute() класса ZipExtractCommand, по аналогии с таким же методом класса
ZipCreateCommand, сделай такой же блок try-catch, только поменяй сообщения выводимые
пользователю, чтобы он понял, что сейчас мы будем распаковывать архив, и что нужно ввести
полное имя архива и директорию, куда будем распаковывать. Не забудь вызвать метод extractAll
класса ZipFileManager, а не createZip, как это было в ZipCreateCommand
5.	Запускай программу и наслаждайся результатом распаковки

Примечание:
Для получения потоков чтения и записи используй Files.newInputStream(Path path), Files.newOutputStream(Path path).



Archiver (18)

Все готово, чтобы реализовать метод execute() класса ZipContentCommand:
1.	Выведи сообщение &quot;Просмотр содержимого архива.&quot;
2.	Создай объект класса ZipFileManager с помощью метода getZipFileManager()
3.	Выведи сообщение &quot;Содержимое архива:&quot;
4.	Получи список файлов архива с помощью метода getFilesList()
5.	Выведи свойства каждого файла в консоль. Тут нам и пригодится ранее реализованный метод
toString() класса FileProperties
6.	Выведи сообщение &quot;Содержимое архива прочитано.&quot;
7.	Запусти программу и проверь, что команда &quot;просмотреть содержимое архива&quot; работает



Archiver (18)

Продолжим наш путь к получению содержимого файла архива. Напишем метод getFilesList() в классе
ZipFileManager. Он будет возвращать список файлов в архиве, вернее список свойств этих файлов (класс
свойств FileProperties мы уже реализовали). Итак:
1.	Добавь метод List&lt;FileProperties&gt; getFilesList() throws Exception в класс ZipFileManager
2.	Внутри метода проверь является ли содержимое zipFile обычным файлом с помощью
подходящего метода класса Files. Если это не файл, брось исключение WrongZipFileException().
3.	Создай список с элементами типа FileProperties, в него мы будем складывать свойства файлов
4.	Создай входящий поток ZipInputStream, для файла из переменной zipFile. Как и в прошлые разы, оберни его создание
в try-with-resources
5.	Пройдись по всем элементам ZipEntry потока ZipInputStream
6.	Для каждого элемента ZipEntry вычитай его содержимое, иначе у нас не будет информации о его
размере. Нельзя узнать размер файла в архиве, не вычитав его. Это очень легко сделать с
помощью функции copyData, используя временный буфер типа ByteArrayOutputStream.
7.	Получи имя, размер, сжатый размер и метод сжатия элемента архива. Посмотри, что еще можно
узнать о нем.
8.	Создай объект класса FileProperties, используя полученные данные о файле.
9.	Добавь созданный объект из п.8 в список из п.3
10.	После выхода из цикла верни собранную информацию вызвавшему методу.



