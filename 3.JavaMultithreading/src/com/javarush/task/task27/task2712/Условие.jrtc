taskKey="com.javarush.task.task27.task2712.big12"\n\nРесторан(12)

У нас выделяются несколько событий:
*повар приготовил заказ
*выбрали набор видео-роликов для заказа
*нет ни одного видео-ролика, который можно показать во время приготовления заказа

Это постоянные данные, поэтому для их хранения подходит энам.

1. В пакете event создай enum EventType {COOKED_ORDER, SELECTED_VIDEOS, NO_AVAILABLE_VIDEO}

2. В пакете event создай три класса, соответствующих значениям энама. Они будут(должны) представлять собой события.
Мы будем регистрировать их экземпляры в хранилище.
Имена классов с параметрами для конструкторов:
2.1. CookedOrderEventDataRow(String tabletName, String cookName, int cookingTimeSeconds, List&lt;Dish&gt; cookingDishes)
где - tabletName - имя планшета
cookName - имя повара
cookingTimeSeconds - время приготовления заказа в секундах
cookingDishes - список блюд для приготовления
2.2. NoAvailableVideoEventDataRow(int totalDuration)
totalDuration - время приготовления заказа в секундах
2.3. VideoSelectedEventDataRow(List&lt;Advertisement&gt; optimalVideoSet, long amount, int totalDuration)
optimalVideoSet - список видео-роликов, отобранных для показа
amount - сумма денег в копейках
totalDuration - общая продолжительность показа отобранных рекламных роликов
3. В классы, созданные в п.2., добавьте поле Date currentDate, которое проинициализируй в конструкторе текущей датой.


Требования:
1.	В пакете event должен быть создан enum EventType с элементами {COOKED_ORDER, SELECTED_VIDEOS, NO_AVAILABLE_VIDEO}.
2.	В пакете event должен быть создан класс CookedOrderEventDataRow реализующий интерфейс EventDataRow с конструктором и полями описанными в условии.
3.	В пакете event должен быть создан класс NoAvailableVideoEventDataRow реализующий интерфейс EventDataRow с конструктором и полями описанными в условии.
4.	В пакете event должен быть создан класс VideoSelectedEventDataRow реализующий интерфейс EventDataRow с конструктором и полями описанными в условии.


Ресторан(12)

Мы реализовали первые две фичи из трех. Напомню, первой была автоматизация приготовления заказа,
второй - подбор рекламных роликов, а третья - статистика для директора. Собственно, к ней мы и добрались.

Нам нужно будет реализовать следующую функциональность:
1) подсчет статистики
2) отображение статистики директору

Попробуем определиться с последовательностью действий. Чтобы отображать данные, сначала нужно их откуда-то получить.

Есть два подхода:
ПЕРВЫЙ - применяется, когда сложно получить реальные данные, либо когда другой человек работает над получением данных:
1. захардкодить данные в приложении
2. отобразить хардкоженную статистику
3. сделать получение реальных данных - реальную статистику (интеграция с чужим кодом)

ВТОРОЙ:
1. сделать получение реальных данных - реальную статистику
2. отобразить статистику

Т.к. мы сами реализовываем данную функциональность, и статистика у нас не сложная, то выберем второй подход.
Начнем с получения реальных данных - реальной статистики.

Идея такая:
Есть хранилище событий.
Когда у нас случается событие, то мы будем регистрировать это событие в хранилище.
На запрос директора мы будем фильтровать события из хранилища, вычислять необходимые данные и отображать их.

Для начала нам нужно несколько классов.
1. Создадим пакет statistic, в котором создадим класс StatisticManager. С его помощью будем регистрировать события в хранилище.
2. У нас должно быть одно хранилище с одной точкой входа. Поэтому сделаем StatisticManager синглтоном.
3. Внутри пакета statistic создадим вложенный пакет event, в котором будут храниться классы, связанные с событиями.
4. Создадим в пакете event интерфейс EventDataRow. На данный момент он является интерфейсом-маркером,
т.к. не содержит методов, и по нему мы определяем, является ли переданный объект событием или нет.
5. В StatisticManager создадим публичный метод void register(EventDataRow data), который будет регистрировать событие в хранилище.
Мы вернемся к реализации позднее.



Ресторан(12)

Рекурсию используют тогда, когда алгоритм решения задачи совпадает с алгоритмом решения подзадачи (части).
У нас как раз такой случай. Нам нужно сделать полный перебор всех вариантов и выбрать из них лучший.

Напомню, рекурсия пишется по следующему принципу:
а) условие выхода/окончания рекурсии
б) условие продолжения - вызов самой себя с набором параметров предыдущего шага.
В любое время ты можешь почитать в инете подробную информацию по написанию рекурсии.

Текущее задание - реализовать п.2.2 предыдущего задания с помощью рекурсии.
(подобрать список видео из доступных, просмотр которых обеспечивает максимальную выгоду)
Рекурсивный метод должен выбрать набор рекламных роликов, которые будут показаны посетителю.

Этот набор должен удовлетворять следующим требованиям:
1) сумма денег, полученная от показов, должна быть максимальной из всех возможных вариантов
2) общее время показа рекламных роликов НЕ должно превышать время приготовления блюд для текущего заказа;
3) для одного заказа любой видео-ролик показывается не более одного раза;
4) если существует несколько вариантов набора видео-роликов с одинаковой суммой денег, полученной от показов, то:
4.1) выбрать тот вариант, у которого суммарное время максимальное;
4.2) если суммарное время у этих вариантов одинаковое, то выбрать вариант с минимальным количеством роликов;
5) количество показов у любого рекламного ролика из набора - положительное число.

Также не забудь реализовать п.2.4 из предыдущего задания (вывести на экран все подходящие ролики в порядке
уменьшения стоимости показа одного рекламного ролика в копейках. Вторичная сортировка - по увеличению стоимости
показа одной секунды рекламного ролика в тысячных частях копейки).

Для каждого показанного видео-ролика должен быть вызван метод revalidate().



Ресторан(12)

Нам понадобится исключение, которое поможет обработать ситуацию, если у нас не будет получаться подобрать рекламные ролики.

1. Создадим unchecked исключение NoVideoAvailableException в пакете ad. Сделаем его потомком класса RuntimeException.

2. Разберем подробно метод void processVideos() в AdvertisementManager.
2.1. Удаляем из него вывод в консоль &quot;calling processVideos method&quot;
Метод должен:
2.2. Подобрать список видео из доступных, просмотр которых обеспечивает максимальную выгоду. (Пока делать не нужно, сделаем позже).
2.3. Если нет рекламных видео, которые можно показать посетителю, то бросить NoVideoAvailableException,
которое перехватить в оптимальном месте (подумать, где это место) и с уровнем Level.INFO логировать фразу
&quot;No video is available for the order &quot; + order
2.4. Отобразить все рекламные ролики, отобранные для показа, в порядке уменьшения стоимости показа одного рекламного ролика
в копейках. Вторичная сортировка - по увеличению стоимости показа одной секунды рекламного ролика в тысячных частях копейки
Используй метод Collections.sort
Пример для заказа [WATER]:
First Video is displaying... 50, 277
где First Video - название рекламного ролика
где 50 - стоимость показа одного рекламного ролика в копейках
где 277 - стоимость показа одной секунды рекламного ролика в тысячных частях копейки (равно 0.277 коп)
Используй методы из класса Advertisement.
(Этот пункт тоже пока делать не нужно, сделаем позже).
2.5. В классе Advertisement создай публичный метод void revalidate(). Этот метод должен:
2.5.1. Бросать UnsupportedOperationException, если количество показов не положительное число.
2.5.2. Уменьшать количество показов на 1.



Ресторан(12)

Пришло время описать функционал класса AdvertisementManager.
Но для начала нам понадобятся некоторые методы в классе Advertisement.

1. В классе Advertisement создай поле long amountPerOneDisplaying.
Оно должно равняться стоимости одного показа рекламного объявления в копейках (initialAmount/hits).
Присвой значение полю в конструкторе.

2. В классе Advertisement создай геттеры для полей name, duration и amountPerOneDisplaying.

3. Определим необходимые данные для объекта AdvertisementManager - это время выполнения заказа поваром.
Т.к. продолжительность видео у нас хранится в секундах, то и время выполнения заказа тоже будем принимать в секундах.
В классе AdvertisementManager создай конструктор, который принимает один параметр - int timeSeconds.
Создай соответствующее поле и сохрани это значение в него.

4. AdvertisementManager выполняет только одно единственное действие - обрабатывает рекламное видео.
Поэтому создай единственный публичный метод void processVideos(), его функционал опишем в следующем задании.
А пока выведем в консоль &quot;calling processVideos method&quot;

5. Чтобы тестировать данную функциональность, нужно добавить вызов processVideos метода у AdvertisementManager.
Очевидно, что этот метод должен вызываться во время создания заказа.
Добавь вызов метода processVideos() в нужное место.

P.S. Не забудь что время приготовления заказа считается в минутах, а время показа рекламы в секундах!



Ресторан(12)

При выборе, с какого класса начать, старайся найти тот, который используют другие, и который сам ничего не использует.
В нашем случае - это хранилище рекламных роликов (AdvertisementStorage).
Мы решили, что оно будет единственным в ресторане и сделали его синглтоном.
Опишем его.

1. Видео должно где-то храниться, пусть это будет список.
Создадим поле List&lt;Advertisement&gt; videos и инициализируем его пустым листом.
Подумай, должно ли поле videos иметь возможность менять свое значение?

2. Чтобы как-то работать с видео, создай публичные методы:
2.1. list() - который вернет список всех существующих доступных видео.
2.2. add(Advertisement advertisement) - который добавит новое видео в список videos.

3. В конструкторе класса  добавим в список videos какие-то данные. У меня это:
Object someContent = new Object();
new Advertisement(someContent, &quot;First Video&quot;, 5000, 100, 3 * 60) // 3 min
new Advertisement(someContent, &quot;Second Video&quot;, 100, 10, 15 * 60) //15 min
new Advertisement(someContent, &quot;Third Video&quot;, 400, 2, 10 * 60)   //10 min

4. В AdvertisementManager создадим final поле-ссылку на экземпляр AdvertisementStorage и назовем ее storage.
Не забудь инициализировать созданное поле!



