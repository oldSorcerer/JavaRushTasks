taskKey="com.javarush.task.task27.task2712.big08"\n\nРесторан(8)

Пришло время описать функционал класса AdvertisementManager.
Но для начала нам понадобятся некоторые методы в классе Advertisement.

1. В классе Advertisement создай поле long amountPerOneDisplaying.
Оно должно равняться стоимости одного показа рекламного объявления в копейках (initialAmount/hits).
Присвой значение полю в конструкторе.

2. В классе Advertisement создай геттеры для полей name, duration и amountPerOneDisplaying.

3. Определим необходимые данные для объекта AdvertisementManager - это время выполнения заказа поваром.
Т.к. продолжительность видео у нас хранится в секундах, то и время выполнения заказа тоже будем принимать в секундах.
В классе AdvertisementManager создай конструктор, который принимает один параметр - int timeSeconds.
Создай соответствующее поле и сохрани это значение в него.

4. AdvertisementManager выполняет только одно единственное действие - обрабатывает рекламное видео.
Поэтому создай единственный публичный метод void processVideos(), его функционал опишем в следующем задании.
А пока выведем в консоль &quot;calling processVideos method&quot;

5. Чтобы тестировать данную функциональность, нужно добавить вызов processVideos метода у AdvertisementManager.
Очевидно, что этот метод должен вызываться во время создания заказа.
Добавь вызов метода processVideos() в нужное место.

P.S. Не забудь что время приготовления заказа считается в минутах, а время показа рекламы в секундах!


Требования:
1.	В классе Advertisement должны быть созданы корректные геттеры для полей name, duration и amountPerOneDisplaying.
2.	В классе Advertisement должно быть создано поле amountPerOneDisplaying равное частному от деления initialAmount на hits.
3.	В классе AdvertisementManager должен быть создан конструктор с одним параметром типа int инициализирующий поле timeSeconds.
4.	В классе AdvertisementManager должен быть создан метод processVideos, оповещающий о своем вызове выводом строки на консоль.
5.	В методе createOrder класса Tablet должен быть создан новый AdvertisementManager и у него должен быть вызван метод processVideos.


Ресторан(8)

При выборе, с какого класса начать, старайся найти тот, который используют другие, и который сам ничего не использует.
В нашем случае - это хранилище рекламных роликов (AdvertisementStorage).
Мы решили, что оно будет единственным в ресторане и сделали его синглтоном.
Опишем его.

1. Видео должно где-то храниться, пусть это будет список.
Создадим поле List&lt;Advertisement&gt; videos и инициализируем его пустым листом.
Подумай, должно ли поле videos иметь возможность менять свое значение?

2. Чтобы как-то работать с видео, создай публичные методы:
2.1. list() - который вернет список всех существующих доступных видео.
2.2. add(Advertisement advertisement) - который добавит новое видео в список videos.

3. В конструкторе класса  добавим в список videos какие-то данные. У меня это:
Object someContent = new Object();
new Advertisement(someContent, &quot;First Video&quot;, 5000, 100, 3 * 60) // 3 min
new Advertisement(someContent, &quot;Second Video&quot;, 100, 10, 15 * 60) //15 min
new Advertisement(someContent, &quot;Third Video&quot;, 400, 2, 10 * 60)   //10 min

4. В AdvertisementManager создадим final поле-ссылку на экземпляр AdvertisementStorage и назовем ее storage.
Не забудь инициализировать созданное поле!



Ресторан(8)

Заказ создается, потом готовится поваром, а после этого относится посетителю. К тому же считается время выполнения заказа.
Будем считать, что первая часть задания выполнена.
Перейдем ко второй - пока заказ готовится, на планшете должна показываться реклама.
Определим, что такое реклама.

Реклама - это видео определенной продолжительности. Также известно, что кто-то оплатил количество показов.
Будем считать, что у нас известно количество оплаченных показов, общая стоимость всех показов и сам рекламный ролик.

1. Для связанного с рекламой функционала создадим пакет ad.

2. Создадим класс Advertisement(Рекламное объявление) в пакете ad, у которого будут следующие поля:
Object content - видео
String name - имя/название
long initialAmount - начальная сумма, стоимость рекламы в копейках. Используем long, чтобы избежать проблем с округлением
int hits - количество оплаченных показов
int duration - продолжительность в секундах
Модификаторы доступа расставь самостоятельно.

3. В классе Advertisement создадим конструктор с порядком аргументов, соответствующим перечисленной последовательности всех полей класса

4. В этом же пакете создадим еще два класса:
AdvertisementStorage - хранилище рекламных роликов.
AdvertisementManager - у каждого планшета будет свой объект менеджера,
который будет подбирать оптимальный набор роликов и их последовательность для каждого заказа.
Он также будет взаимодействовать с плеером и отображать ролики.

5. Так как хранилище рекламных роликов AdvertisementStorage единственное для всего ресторана, то сделаем его синглтоном.



Ресторан(8)

Сейчас повар готовит блюда моментально. На самом деле приготовление занимает какое-то время.
Нам нужно вычислить время приготовления всего заказа, чтобы потом подбирать рекламные ролики для этого времени.

1. Предположим, что нам известно время приготовления каждого блюда в минутах. Захардкодим его в классе Dish.
1.1. Измени создание элементов enum - FISH(25), STEAK(30), SOUP(15), JUICE(5), WATER(3);
1.2. Создай поле private int duration с геттером.
Чтобы создать геттер, нажми Alt+Insert и выбери пункт Getter. Далее выбери имя поля и нажмите OK(Enter).
1.3. Создай конструктор Dish(int duration), в котором инициализируй поле duration.
Чтобы создать конструктор, нажми Alt+Insert и выбери пункт Constructor. Далее выбери имя поля и нажми OK(Enter).

2. Добавим возможность посчитать продолжительность приготовления всего заказа.
Куда его добавить???
2.1. Если в класс Cook, то повар сможет считать продолжительность приготовления заказа.
Чтобы другие классы могли получить эту информацию, необходимо будет получить доступ к объекту Cook.
2.2. Если в класс Order, то имея доступ к заказу всегда можно узнать продолжительность приготовления.
2.3. Выбери правильное место из п.2.1. и п.2.2. и добавьте метод public int getTotalCookingTime(),
который посчитает суммарное время приготовления всех блюд в заказе.
2.4. Добавим вывод в консоль этой информации. Пусть теперь информация о заказе выводится в таком виде:
Your order: [SOUP, JUICE, WATER] of Tablet{number=5}, cooking time 23min

Наведем красоту:
3. Запустим приложение и сразу введем &#39;exit&#39;. Вывод получился не очень красивым:
Start cooking - , cooking time 0min
was cooked by Amigo
Сделай так, чтобы если в заказе нет блюд, он не отправлялся повару. Найди это место и реализуй логику.
Для этого также в классе Order создай вспомогательный метод public boolean isEmpty(), который будет определять, есть ли какие либо блюда в заказе.



Ресторан(8)

Что мы имеем? Повар приготовил блюда, пора их уносить, а официант не знает об этом.
Нужно уведомить официанта, что пора забирать заказ с кухни.
Ситуация аналогична предыдущему заданию, поэтому снова будем использовать паттерн Observer.

1. Создадим класс Waiter(Официант) в пакете kitchen, он будет относить заказы назад к столику. Официант будет безымянным.

2. Cook(Повар) готовит заказы, а Waiter их обрабатывает. Расставь правильно Observer и Observable между Waiter и Cook.

3. Метод void update будет выводить в консоль сообщение о том, какой заказ и кем был приготовлен:
order + &quot; was cooked by &quot; + cook

4. В классе наследнике Observable перед отправкой заказа сделаем следующее:
4.1. Установим флаг setChanged()
4.2. Отправим наблюдателю заказ - notifyObservers(order);

5. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo :)

Сверим выводы в консоль. Пример моего вывода:
Your order: [WATER] of Tablet{number=5}
Start cooking - Your order: [WATER] of Tablet{number=5}
Your order: [WATER] of Tablet{number=5} was cooked by Amigo



Ресторан(8)

Сейчас мы можем создавать заказы. Давай сделаем так, чтобы они автоматически поступали к повару.
Есть много различных способов реализации данной функциональности.
Почитай про паттерн Observer - http://en.wikipedia.org/wiki/Observer_pattern
Он уже реализован в java, и мы его будем использовать.

1. Создадим класс Cook(Повар) в пакете kitchen, он будет готовить. Пусть в конструкторе приходит его имя, которое выводится методом toString.

2. Tablet создает заказы, а Cook их обрабатывает. Расставь правильно Observer и Observable между Tablet и Cook.

3. Метод void update(Observable observable, Object arg), который необходимо реализовать, принимает два параметра.
-observable - объект, который отправил нам значение
-arg - само значение, в нашем случае - это объект Order
На данном этапе мы будем лишь имитировать обработку и выведем в консоль &quot;Start cooking - &quot; + order

3. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo :)

Сверим выводы в консоль. Пример моего вывода:
Your order: [SOUP] of Tablet{number=5}
Start cooking - Your order: [SOUP] of Tablet{number=5}

4. Не забудь сразу после создания заказа и вывода информации о нем в консоль (найди это место в коде) сделать следующее:
4.1. Установить флаг setChanged()
4.2. Отправить обсерверу заказ - notifyObservers(order);

5. Также внесем небольшое изменение. Сделай так чтобы метод createOrder возвращал текущий заказ или null, если заказ создать не удалось.



