taskKey="com.javarush.task.task27.task2712.big14"\n\nРесторан(14)

1. Внутри StatisticStorage создай метод void put(EventDataRow data).

2. Чтобы методом put(EventDataRow data) добавить объект data в данные карты, нужен тип события - EventType.
Будет правильно, если событие будет хранить в себе свой тип. Поэтому:
2.1. В интерфейс EventDataRow добавь метод EventType getType()
2.2. Реализуй этот метод в каждом классе-событии: CookedOrderEventDataRow, NoAvailableVideoEventDataRow, VideoSelectedEventDataRow

3. Сделай так, чтобы к методу void put(EventDataRow data) нельзя было получить доступ за пределами класса StatisticManager.
Воспользуйся особенностями вложенных классов.

Теперь остается расставить вызовы StatisticManager в те места, которые генерируют события.

4. Зарегистрируй событие для повара во время приготовления еды.
Добавь геттер для поля dishes в класс Order, используй его при создании события.

5. Зарегистрируй событие &quot;видео выбрано&quot; перед отображением рекламы пользователю.

6. Метод register с одним параметром типа EventDataRow должен регистрировать полученное событие в statisticStorage.


Требования:
1.	В интерфейсе EventDataRow должен быть объявлен метод EventType getType().
2.	В классах поддерживающих интерфейс EventDataRow должен быть корректно реализован метод getType().
3.	Метод put в классе StatisticStorage должен быть реализован в соответствии с условием задачи.
4.	Метод register класса StatisticManager с одним параметром типа EventDataRow должен регистрировать полученное событие в statisticStorage.
5.	Повар во время приготовления еды должен генерировать соответствующее событие.
6.	Перед отображением списка видео должно быть зарегистрировано событие &quot;видео выбрано&quot;.


Ресторан(14)

Вернемся к методу register в классе StatisticManager. Он должен регистрировать события в хранилище.
Создадим хранилище :)
Хранилище связано 1 к 1 с менеджером, т.е. один менеджер и одно хранилище на приложение.
К хранилищу может доступиться только StatisticManager. Поэтому...
Из вышеперечисленного следует, что хранилище должно быть приватным иннер классом.
Назовем его StatisticStorage.

1. Внутри класса StatisticManager создать приватный иннер класс StatisticStorage.

2. Чтобы менеджер мог получить доступ к хранилищу, нужно в классе StatisticManager создать поле statisticStorage типа StatisticStorage.
Инициализируй его экземпляром класса.

3. StatisticStorage будет хранить данные внутри себя в виде мапы/словаря storage.
Связь StatisticStorage и Map должна быть has-a
Типы для мапы - &lt;EventType, List&lt;EventDataRow&gt;&gt;

4. В конструкторе StatisticStorage инициализируй хранилище данными по-умолчанию:
например используя цикл, для каждого EventType добавь new ArrayList&lt;EventDataRow&gt;()



Ресторан(14)

У нас выделяются несколько событий:
*повар приготовил заказ
*выбрали набор видео-роликов для заказа
*нет ни одного видео-ролика, который можно показать во время приготовления заказа

Это постоянные данные, поэтому для их хранения подходит энам.

1. В пакете event создай enum EventType {COOKED_ORDER, SELECTED_VIDEOS, NO_AVAILABLE_VIDEO}

2. В пакете event создай три класса, соответствующих значениям энама. Они будут(должны) представлять собой события.
Мы будем регистрировать их экземпляры в хранилище.
Имена классов с параметрами для конструкторов:
2.1. CookedOrderEventDataRow(String tabletName, String cookName, int cookingTimeSeconds, List&lt;Dish&gt; cookingDishes)
где - tabletName - имя планшета
cookName - имя повара
cookingTimeSeconds - время приготовления заказа в секундах
cookingDishes - список блюд для приготовления
2.2. NoAvailableVideoEventDataRow(int totalDuration)
totalDuration - время приготовления заказа в секундах
2.3. VideoSelectedEventDataRow(List&lt;Advertisement&gt; optimalVideoSet, long amount, int totalDuration)
optimalVideoSet - список видео-роликов, отобранных для показа
amount - сумма денег в копейках
totalDuration - общая продолжительность показа отобранных рекламных роликов
3. В классы, созданные в п.2., добавьте поле Date currentDate, которое проинициализируй в конструкторе текущей датой.



Ресторан(14)

Мы реализовали первые две фичи из трех. Напомню, первой была автоматизация приготовления заказа,
второй - подбор рекламных роликов, а третья - статистика для директора. Собственно, к ней мы и добрались.

Нам нужно будет реализовать следующую функциональность:
1) подсчет статистики
2) отображение статистики директору

Попробуем определиться с последовательностью действий. Чтобы отображать данные, сначала нужно их откуда-то получить.

Есть два подхода:
ПЕРВЫЙ - применяется, когда сложно получить реальные данные, либо когда другой человек работает над получением данных:
1. захардкодить данные в приложении
2. отобразить хардкоженную статистику
3. сделать получение реальных данных - реальную статистику (интеграция с чужим кодом)

ВТОРОЙ:
1. сделать получение реальных данных - реальную статистику
2. отобразить статистику

Т.к. мы сами реализовываем данную функциональность, и статистика у нас не сложная, то выберем второй подход.
Начнем с получения реальных данных - реальной статистики.

Идея такая:
Есть хранилище событий.
Когда у нас случается событие, то мы будем регистрировать это событие в хранилище.
На запрос директора мы будем фильтровать события из хранилища, вычислять необходимые данные и отображать их.

Для начала нам нужно несколько классов.
1. Создадим пакет statistic, в котором создадим класс StatisticManager. С его помощью будем регистрировать события в хранилище.
2. У нас должно быть одно хранилище с одной точкой входа. Поэтому сделаем StatisticManager синглтоном.
3. Внутри пакета statistic создадим вложенный пакет event, в котором будут храниться классы, связанные с событиями.
4. Создадим в пакете event интерфейс EventDataRow. На данный момент он является интерфейсом-маркером,
т.к. не содержит методов, и по нему мы определяем, является ли переданный объект событием или нет.
5. В StatisticManager создадим публичный метод void register(EventDataRow data), который будет регистрировать событие в хранилище.
Мы вернемся к реализации позднее.



Ресторан(14)

Рекурсию используют тогда, когда алгоритм решения задачи совпадает с алгоритмом решения подзадачи (части).
У нас как раз такой случай. Нам нужно сделать полный перебор всех вариантов и выбрать из них лучший.

Напомню, рекурсия пишется по следующему принципу:
а) условие выхода/окончания рекурсии
б) условие продолжения - вызов самой себя с набором параметров предыдущего шага.
В любое время ты можешь почитать в инете подробную информацию по написанию рекурсии.

Текущее задание - реализовать п.2.2 предыдущего задания с помощью рекурсии.
(подобрать список видео из доступных, просмотр которых обеспечивает максимальную выгоду)
Рекурсивный метод должен выбрать набор рекламных роликов, которые будут показаны посетителю.

Этот набор должен удовлетворять следующим требованиям:
1) сумма денег, полученная от показов, должна быть максимальной из всех возможных вариантов
2) общее время показа рекламных роликов НЕ должно превышать время приготовления блюд для текущего заказа;
3) для одного заказа любой видео-ролик показывается не более одного раза;
4) если существует несколько вариантов набора видео-роликов с одинаковой суммой денег, полученной от показов, то:
4.1) выбрать тот вариант, у которого суммарное время максимальное;
4.2) если суммарное время у этих вариантов одинаковое, то выбрать вариант с минимальным количеством роликов;
5) количество показов у любого рекламного ролика из набора - положительное число.

Также не забудь реализовать п.2.4 из предыдущего задания (вывести на экран все подходящие ролики в порядке
уменьшения стоимости показа одного рекламного ролика в копейках. Вторичная сортировка - по увеличению стоимости
показа одной секунды рекламного ролика в тысячных частях копейки).

Для каждого показанного видео-ролика должен быть вызван метод revalidate().



Ресторан(14)

Нам понадобится исключение, которое поможет обработать ситуацию, если у нас не будет получаться подобрать рекламные ролики.

1. Создадим unchecked исключение NoVideoAvailableException в пакете ad. Сделаем его потомком класса RuntimeException.

2. Разберем подробно метод void processVideos() в AdvertisementManager.
2.1. Удаляем из него вывод в консоль &quot;calling processVideos method&quot;
Метод должен:
2.2. Подобрать список видео из доступных, просмотр которых обеспечивает максимальную выгоду. (Пока делать не нужно, сделаем позже).
2.3. Если нет рекламных видео, которые можно показать посетителю, то бросить NoVideoAvailableException,
которое перехватить в оптимальном месте (подумать, где это место) и с уровнем Level.INFO логировать фразу
&quot;No video is available for the order &quot; + order
2.4. Отобразить все рекламные ролики, отобранные для показа, в порядке уменьшения стоимости показа одного рекламного ролика
в копейках. Вторичная сортировка - по увеличению стоимости показа одной секунды рекламного ролика в тысячных частях копейки
Используй метод Collections.sort
Пример для заказа [WATER]:
First Video is displaying... 50, 277
где First Video - название рекламного ролика
где 50 - стоимость показа одного рекламного ролика в копейках
где 277 - стоимость показа одной секунды рекламного ролика в тысячных частях копейки (равно 0.277 коп)
Используй методы из класса Advertisement.
(Этот пункт тоже пока делать не нужно, сделаем позже).
2.5. В классе Advertisement создай публичный метод void revalidate(). Этот метод должен:
2.5.1. Бросать UnsupportedOperationException, если количество показов не положительное число.
2.5.2. Уменьшать количество показов на 1.



