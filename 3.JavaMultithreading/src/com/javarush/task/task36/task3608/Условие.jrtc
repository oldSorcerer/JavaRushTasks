taskKey="com.javarush.task.task36.task3608.big06"\n\nMVC (6)

Функционал отображения удаленных пользователей есть, а самих таких пользователей нет. Давай это исправим.
Давай сделаем новую Вью - EditUserView, которая будет отвечать за редактирование одного конкретного пользователя.
UsersView отображает список пользователей.
EditUserView будет отображать данные о редактировании конкретного пользователя.
Для этого нам сначала нужен этот выбранный пользователь.
Как и любые данные его поместим в ModelData.

1. Создай в ModelData поле User activeUser с геттером и сеттером (Alt+Insert -&gt; Getter and Setter).

2. Аналогично UsersView создай EditUserView.
Логика метода refresh:
2.1. Вывести в консоль &quot;User to be edited:&quot;.
2.2. С новой строки вывести табуляцию и активного пользователя.
2.3. С новой строки вывести разделитель &quot;===================================================&quot;.

3. Создай в контроллере поле EditUserView editUserView с сеттером.

Когда наши данные выводятся в консоль, то совсем не понятно, список каких пользователей - удаленных или нет - выводится.
Давай сделаем так, чтобы Вью отображала эту информацию. Все данные для отображения хранятся в Модели. Поэтому:
4. создай в ModelData поле boolean displayDeletedUserList с геттером и сеттером.

5. Измени метод refresh в UsersView так, чтобы он отображал &quot;All users:&quot; либо &quot;All deleted users:&quot;
в зависимости от того, какие пользователи находятся в списке. Добавь в необходимые методы модели изменение displayDeletedUserList.


Требования:
1.	В классе ModelData должно быть создано приватное поле User activeUser, геттер и сеттер для этого поля.
2.	Класс EditUserView должен быть создан аналогично классу UsersView: он должен поддерживать интерфейс View, содержать приватное поле Controller controller и сеттер этого поля.
3.	Метод refresh класса EditUserView должен быть реализован согласно условию.
4.	В классе Controller должно быть создано приватное поле EditUserView editUserView и сеттер этого поля.
5.	В классе ModelData должно быть создано приватное поле boolean displayDeletedUserList, геттер и сеттер для этого поля.
6.	Метод refresh в классе UsersView должен быть изменен согласно условию.
7.	Необходимо добавить в некоторые методы класса MainModel вызов метода setDisplayDeletedUserList(boolean) с правильным флагом.


MVC (6)

В сервисе есть метод, который возвращает всех удаленных пользователей. Давай их отобразим.

1. Распредели методы по классам MVC:

public void fireEventShowDeletedUsers() {
...onShowAllDeletedUsers();
}

public void onShowAllDeletedUsers() {
...loadDeletedUsers();
}

public void loadDeletedUsers() {
List&lt;User&gt; users = userService.getAllDeletedUsers();
}

Не забудь, что данные, полученные с сервера, необходимо положить в ModelData. А потом обновить view.
Добавь это самостоятельно в нужные методы.

2. Добавь в Solution.main вызов нового метода, который ты поместил в view.

3. Добавь в интерфейс Model метод, который ты поместил в Модель, реализуй его в FakeModel: выброси UnsupportedOperationException.



MVC (6)

Пора заменять нашу фейковую Модель на реальную, которая будет получать данные из DataSource.
В пакет model.service я добавил сервис для работы с пользователями.
Также в корне этой задачи ты найдешь утильный класс Util.

1. Аналогично FakeModel создай модель MainModel.

2. Т.к. Модель обращается к сервисам, то в MainModel создай поле UserService userService, инициализируй объектом.

3. Реализуй логику метода loadUsers:
3.1. Достань всех пользователей между 1 и 100 уровнями. (Метод getUsersBetweenLevels(1, 100)).
3.2. Положи всех пользователей в modelData.

4. Обнови Solution.main: замени FakeModel на MainModel.
Преимущества MVC в том, что в любой момент времени легко можно заменить любую часть паттерна.



MVC (6)

Чтобы понимать, в правильном ли направлении ты движешься, тебе надо видеть данные. Поэтому:
1. В пакете view создай класс UsersView, реализующий View. Он будет отображать список пользователей в консоль.

2. В UsersView создай поле-контроллер, также создай ему сеттер.

3. Реализуй логику метода refresh:
3.1. Выведи в консоль фразу &quot;All users:&quot;.
3.2. Выведи в консоль всех пользователей, которые есть в modelData.
Перед каждым пользователем сделай отступ в виде табуляции.
3.3. В конце выведи визуальный разделитель данных
===================================================

4. Уже интересно посмотреть, что же получилось.
Добавь в UsersView публичный метод void fireEventShowAllUsers(), который будет эмулировать событие клиента.
Обратись к контроллеру и вызови его нужный метод для отображения всех пользователей.

5. Класс Solution будет эмулятором пользователя. Открой класс Solution, стань на красный метод,
с помощью горячих клавиш Идеи создай проперти(поле) для usersView.
Нужен только сеттер. Если у тебя создался геттер, то удали его.

6. Запусти main. Упс, ничего не вывело :(
Это получилось потому, что данные пришли с сервера, обновились в ModelData, но Вью ничего о них не знает.
Вью сама не умеет себя обновлять. Это делает Контроллер.
Пойди в контроллер и добавь обновление данных во Вью.
Напомню, данные хранятся в Модели.

7. Запусти main. У меня теперь такой вывод:
All users:
User{name=&#39;A&#39;, id=1, level=1}
User{name=&#39;B&#39;, id=2, level=1}
===================================================
Ура, идем дальше.



MVC (6)

1. Создай пакет controller, в котором создай класс Controller.
Этот класс будет получать запрос от клиента, оповещать Модель об этом, а Модель, в свою очередь, будет обновлять ModelData.

2. Добавь в контроллер поле Model model вместе с сеттером.

3. В контроллере создай публичный метод void onShowAllUsers(), который должен обратиться к модели и инициировать загрузку пользователей.

4. Создай пакет view. В нем создай интерфейс View.

5. В интерфейс View добавь два метода: void refresh(ModelData modelData) и void setController(Controller controller).



MVC (6)

Привет! Эта задача будет на паттерн MVC - Model-View-Controller.
Мы вместе построим архитектуру используя MVC. Разберись подробно, что и почему нужно реализовывать так, как я тебе покажу.
Прочти дополнительную литературу, которую дает профессор в конце уровня.
Тебя, скорее всего, на собеседовании спросят об этом паттерне либо дадут задание, в котором нужно будет его реализовать.

Итак...
У тебя есть два пакета: bean, содержащий единственный класс User, и dao,
в котором хранится эмуляция базы данных в пакете mock и UserDao. UserDao - это уровень ДАО, т.е. уровень доступа к базе.
В нем размещают различные методы по сохранению и получению объектов из базы данных.
В реальном приложении строку private DataSource dataSource = DataSource.getInstance() не встретить.
Я реализовал DataSource в виде синглтона. В действительности, у тебя будет что-то такое:
@Autowired
private DataSource dataSource;
Фреймворк, которым ты будешь пользоваться, сам создаст объект базы данных и инициализирует поле dataSource.

Запомни, с ДАО уровнем работают сервисы. Никакие другие классы в ДАО не лезут. В сервисах описана бизнес логика.
Сервисы забирают данные из базы используя ДАО, обрабатывают их и отдают тому, кто данные запросил.
Однако не все данные хранятся в базе. Например, залогиненый пользователь будет храниться в специальном объекте - Модели.
Объект, который содержит в себе данные, необходимые для отображения информации на клиенте, называется Моделью.
Также этот объект Модель содержит ссылки на все необходимые сервисы.
Если данных для отображения очень много, то их выделяют в отдельный объект.

Напишем приложение, которое будет показывать список пользователей и что-то делать с ними, например, обновлять их данные и удалять.

1. Создай пакет model, в котором создай класс ModelData.
ModelData - это объект, который будет хранить необходимые данные для отображения на клиенте.
Создай поле с геттером и сеттером List&lt;User&gt; users - это будет список пользователей для отображения.

2. Используя любую модель должна быть возможность получить все необходимые данные для отображения. Поэтому
в пакете model создай интерфейс Model, который должен содержать метод ModelData getModelData().

3. В пакете model создай класс FakeModel, реализующий Model. Он нам понадобится на начальном этапе.
В нем создай поле ModelData modelData, которое инициализируй объектом. Метод getModelData() должен возвращать значение поля modelData.

4. В интерфейсе Model создай метод void loadUsers().
Реализуй его в FakeModel: инициализируй список пользователей modelData любыми данными. Они не влияют на тестирование.
У меня такие данные:
User{name=&#39;A&#39;, id=1, level=1}
User{name=&#39;B&#39;, id=2, level=1}
Думаю, ты помнишь, что все методы интерфейса являются public-ами, поэтому модификатор указывать не нужно.
Программисты часто мОкают данные на начальном этапе. Получение реальных данных реализуется на последних этапах.
Мокать - это подменять реальные объекты на хардкоженные, тестовые данные.



