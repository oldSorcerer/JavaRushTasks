taskKey="com.javarush.task.task36.task3608.big08"\n\nMVC (8)

1. Следуя принципу MVC аналогично реализации предыдущих методов сделай следующее:
напиши логику удаления пользователя. После удаления должен отображаться список пользователей.
Распредели следующие методы по классам MVC:
public void fireEventUserDeleted(long id)
public void onUserDelete(long id)
public void deleteUserById(long id)
Примечание: метод, который ты собираешься добавить в Вью нужно добавить в EditUserView.

2. Добавь в main вызов fireEventUserDeleted(124L) перед вызовом метода fireEventShowDeletedUsers().

3. Выполни рефакторинг класса MainModel. Теперь, когда есть удаленные пользователи, часть методов стала работать неправильно.
Почти во всех методах, где требуется список пользователей, нужно работать только с активными(живыми) пользователями.
Вынеси в отдельный приватный метод List&lt;User&gt; getAllUsers() получение списка всех активных пользователей.
Фильтрация активных пользователей у тебя уже есть - метод List&lt;User&gt; filterOnlyActiveUsers(List&lt;User&gt; allUsers).
Отрефактори все методы, которые используют список пользователей. Они должны использовать список живых пользователей.

4. Добавь в интерфейс Model метод, который ты поместил в Модель, реализуй его в FakeModel: выброси UnsupportedOperationException.


Требования:
1.	Необходимо определить правильное расположение метода fireEventUserDeleted(long) и реализовать этот метод.
2.	Необходимо определить правильное расположение метода onUserDelete(long) и реализовать этот метод.
3.	Необходимо определить правильное расположение метода deleteUserById(long) и реализовать этот метод.
4.	В методе main класса Solution необходимо вызвать метод fireEventUserDeleted(124L) у объекта класса EditUserView перед вызовом метода fireEventShowDeletedUsers().
5.	В методе main вызов методов должен происходить в такой последовательности: fireEventShowAllUsers(), fireEventOpenUserEditForm(126L), fireEventUserDeleted(124L), fireEventShowDeletedUsers().
6.	Необходимо реализовать приватный метод List&lt;User&gt; getAllUsers() в классе MainModel.
7.	Необходимо выполнить рефакторинг: все методы класса MainModel, которые используют список пользователей, должны использовать список живых пользователей.
8.	Интерфейс Model должен содержать объявление метода, который ты ранее реализовал в классе MainModel.
9.	В классе FakeModel в теле метода, помещенного в интерфейс Model, необходимо бросить UnsupportedOperationException.


MVC (8)

1. Распредели методы по классам MVC:

public void onOpenUserEditForm(long userId) {
...loadUserById(userId);
...refresh(...getModelData());
}

public void fireEventOpenUserEditForm(long id) {
...onOpenUserEditForm(id);
}

public void loadUserById(long userId) {
User user = userService.getUsersById(userId);
...setActiveUser(user);
}

!!!! Пользователь видит Вью со списком пользователей, нажимает на одного из них, запрос идет на сервер,
выгребаем новые данные и отображаем другую Вью, которая относится к одному выбранному пользователю.
Учти это при реализации этого задания.

2. Добавь в метод main открытие формы редактирования для пользователя с id=126 перед вызовом метода fireEventShowDeletedUsers().

3. Добавь в интерфейс Model метод, который ты поместил в Модель, реализуй его в FakeModel: выброси UnsupportedOperationException.



MVC (8)

Функционал отображения удаленных пользователей есть, а самих таких пользователей нет. Давай это исправим.
Давай сделаем новую Вью - EditUserView, которая будет отвечать за редактирование одного конкретного пользователя.
UsersView отображает список пользователей.
EditUserView будет отображать данные о редактировании конкретного пользователя.
Для этого нам сначала нужен этот выбранный пользователь.
Как и любые данные его поместим в ModelData.

1. Создай в ModelData поле User activeUser с геттером и сеттером (Alt+Insert -&gt; Getter and Setter).

2. Аналогично UsersView создай EditUserView.
Логика метода refresh:
2.1. Вывести в консоль &quot;User to be edited:&quot;.
2.2. С новой строки вывести табуляцию и активного пользователя.
2.3. С новой строки вывести разделитель &quot;===================================================&quot;.

3. Создай в контроллере поле EditUserView editUserView с сеттером.

Когда наши данные выводятся в консоль, то совсем не понятно, список каких пользователей - удаленных или нет - выводится.
Давай сделаем так, чтобы Вью отображала эту информацию. Все данные для отображения хранятся в Модели. Поэтому:
4. создай в ModelData поле boolean displayDeletedUserList с геттером и сеттером.

5. Измени метод refresh в UsersView так, чтобы он отображал &quot;All users:&quot; либо &quot;All deleted users:&quot;
в зависимости от того, какие пользователи находятся в списке. Добавь в необходимые методы модели изменение displayDeletedUserList.



MVC (8)

В сервисе есть метод, который возвращает всех удаленных пользователей. Давай их отобразим.

1. Распредели методы по классам MVC:

public void fireEventShowDeletedUsers() {
...onShowAllDeletedUsers();
}

public void onShowAllDeletedUsers() {
...loadDeletedUsers();
}

public void loadDeletedUsers() {
List&lt;User&gt; users = userService.getAllDeletedUsers();
}

Не забудь, что данные, полученные с сервера, необходимо положить в ModelData. А потом обновить view.
Добавь это самостоятельно в нужные методы.

2. Добавь в Solution.main вызов нового метода, который ты поместил в view.

3. Добавь в интерфейс Model метод, который ты поместил в Модель, реализуй его в FakeModel: выброси UnsupportedOperationException.



MVC (8)

Пора заменять нашу фейковую Модель на реальную, которая будет получать данные из DataSource.
В пакет model.service я добавил сервис для работы с пользователями.
Также в корне этой задачи ты найдешь утильный класс Util.

1. Аналогично FakeModel создай модель MainModel.

2. Т.к. Модель обращается к сервисам, то в MainModel создай поле UserService userService, инициализируй объектом.

3. Реализуй логику метода loadUsers:
3.1. Достань всех пользователей между 1 и 100 уровнями. (Метод getUsersBetweenLevels(1, 100)).
3.2. Положи всех пользователей в modelData.

4. Обнови Solution.main: замени FakeModel на MainModel.
Преимущества MVC в том, что в любой момент времени легко можно заменить любую часть паттерна.



MVC (8)

Чтобы понимать, в правильном ли направлении ты движешься, тебе надо видеть данные. Поэтому:
1. В пакете view создай класс UsersView, реализующий View. Он будет отображать список пользователей в консоль.

2. В UsersView создай поле-контроллер, также создай ему сеттер.

3. Реализуй логику метода refresh:
3.1. Выведи в консоль фразу &quot;All users:&quot;.
3.2. Выведи в консоль всех пользователей, которые есть в modelData.
Перед каждым пользователем сделай отступ в виде табуляции.
3.3. В конце выведи визуальный разделитель данных
===================================================

4. Уже интересно посмотреть, что же получилось.
Добавь в UsersView публичный метод void fireEventShowAllUsers(), который будет эмулировать событие клиента.
Обратись к контроллеру и вызови его нужный метод для отображения всех пользователей.

5. Класс Solution будет эмулятором пользователя. Открой класс Solution, стань на красный метод,
с помощью горячих клавиш Идеи создай проперти(поле) для usersView.
Нужен только сеттер. Если у тебя создался геттер, то удали его.

6. Запусти main. Упс, ничего не вывело :(
Это получилось потому, что данные пришли с сервера, обновились в ModelData, но Вью ничего о них не знает.
Вью сама не умеет себя обновлять. Это делает Контроллер.
Пойди в контроллер и добавь обновление данных во Вью.
Напомню, данные хранятся в Модели.

7. Запусти main. У меня теперь такой вывод:
All users:
User{name=&#39;A&#39;, id=1, level=1}
User{name=&#39;B&#39;, id=2, level=1}
===================================================
Ура, идем дальше.



