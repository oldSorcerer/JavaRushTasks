taskKey="com.javarush.task.task32.task3209.big14"\n\nHTML Editor (14)

14.1.	Добавь в класс представления метод selectHtmlTab(). Он должен:
14.1.1.	Выбирать html вкладку (переключаться на нее).
14.1.2.	Сбрасывать все правки с помощью метода, который ты реализовал ранее.
14.2.	Добавь в класс контроллера геттер для модели, в нашем случае это поле document.
14.3.	Добавь в представление метод update(), который должен получать документ у
контроллера и устанавливать его в панель редактирования htmlTextPane.
14.4.	Добавь в представление метод showAbout(), который должен показывать диалоговое
окно с информацией о программе. Информацию придумай сам, а вот тип сообщения
должен быть JOptionPane.INFORMATION_MESSAGE.


Требования:
1.	Класс View должен содержать публичный метод selectHtmlTab(), который должен выбирать вкладку и сбрасывать все правки.
2.	Класс Controller должен содержать геттер для поля document.
3.	Класс View должен содержать публичный метод update(), который должен устанавливать документ в панель редактирования.
4.	Класс View должен содержать публичный метод showAbout(), который должен показывать диалоговое окно с информацией о программе.


HTML Editor (14)

Реализуем класс TextEditMenuListener в пакет listeners. Этот класс будет работать аналогично
классу UndoMenuListener только для других пунктов меню. Пункты меню, отвечающие за
стиль, шрифт, цвет и т.д. должны быть доступны только тогда, когда в нашем редакторе
выбрана первая вкладка.
13.1.	Добавь в представление метод boolean isHtmlTabSelected(). Он должен возвращать
true, если выбрана вкладка, отображающая html в панели вкладок (подсказка: ее индекс 0).
13.2.	Добавь в класс TextEditMenuListener поле View, проинициализируй его в конструкторе
класса.
13.3.	В классе TextEditMenuListener переопредели метод menuSelected(MenuEvent
menuEvent). Он должен:
13.3.1.	Из переданного параметра получать объект, над которым было совершено действие. В
нашем случае это будет объект с типом JMenu.
13.3.2.	У полученного меню получать список компонентов (пунктов меню).
13.3.3.	Для каждого пункта меню вызывать метод setEnabled, передав в качестве параметра
результат вызова метода isHtmlTabSelected() из представления.
Запусти приложение и убедись, что пункты меню стиль, выравнивание, цвет и шрифт доступны
только, когда активна закладка HTML и не доступны для закладки Текст.



HTML Editor (14)

12.1.	Напиши реализацию класса RedoAction:
12.1.1.	Добавь в класс поле View. Добавь его инициализацию в конструкторе.
12.1.2.	Реализуй метод actionPerformed(ActionEvent actionEvent), он должен вызывать метод
redo() у представления.
12.2.	Напиши реализацию класса UndoAction по аналогии с RedoAction.
12.3.	Изучи реализацию класса StrikeThroughAction, которую ты получил вместе с заданием и
реализуй аналогичным образом классы:
12.3.1.	SubscriptAction
12.3.2.	SuperscriptAction
Запусти программу и убедись, что пункты меню Подстрочный знак, Надстрочный знак и
Зачеркнутый работают. Пункты, отвечающие за отмену и возврат действия пока не
подключены к контроллеру и мы не сможем их проверить.



HTML Editor (14)

11.1.	Добавь в представление поле UndoManager undoManager. Разберись для чего
используется этот класс. Проинициализируй поле класса новым объектом.
11.2.	Добавь класс UndoListener реализующий интерфейс UndoableEditListener в пакет
listeners. Этот класс будет следить за правками, которые можно отменить или вернуть.
11.3.	Добавь в класс UndoListener:
11.3.1.	Поле UndoManager undoManager.
11.3.2.	Конструктор, который принимает UndoManager и инициализирует поле класса.
11.3.3.	Метод undoableEditHappened(UndoableEditEvent e). Он должен из переданного
события получать правку и добавлять ее в undoManager.
11.4.	Добавь в представление поле UndoListener undoListener, проинициализируй его
используя undoManager.
11.5.	Добавь в представление методы:
11.5.1.	void undo() - отменяет последнее действие. Реализуй его используя undoManager.
Метод не должен кидать исключений, логируй их.
11.5.2.	void redo() - возвращает ранее отмененное действие. Реализуй его по аналогии с
предыдущим пунктом.
11.5.3.	Реализуй методы boolean canUndo() и boolean canRedo() используя undoManager.
11.5.4.	Реализуй геттер для undoListener.
11.5.5.	Добавь и реализуй метод void resetUndo(), который должен сбрасывать все правки в
менеджере undoManager.



HTML Editor (14)

Наш редактор будет поддерживать механизм отмены/возврата (undo/redo) действий в
редакторе.
Реализуй класс UndoMenuListener. Этот слушатель будет следить за меню, а если конкретнее,
то за моментом, когда меню редактирования будет выбрано пользователем. В этот момент он
будет запрашивать у представления можем ли мы сейчас отменить или вернуть какое-то
действие, и в зависимости от этого делать доступными или не доступными пункты меню
&quot;Отменить&quot; и &quot;Вернуть&quot;.
10.1.	Добавь в класс UndoMenuListener следующие поля:
10.1.1.	Представление View view.
10.1.2.	Пункт меню &quot;Отменить&quot; JMenuItem undoMenuItem.
10.1.3.	Пункт меню &quot;Вернуть&quot; JMenuItem redoMenuItem.
10.2.	Реализуй конструктор UndoMenuListener(View view, JMenuItem undoMenuItem,
JMenuItem redoMenuItem), он должен инициализировать поля класса.
10.3.	Реализуй метод menuSelected(MenuEvent menuEvent). Он будет вызываться перед
показом меню. Он должен:
10.3.1.	Спрашивать у представления можем ли мы отменить действие с помощью метода
boolean canUndo(). Пока у представления нет такого метода, поэтому добавь заглушку,
которая всегда возвращает false.
10.3.2.	Делать доступным или не доступным пункт меню undoMenuItem в зависимости от того,
что нам вернуло представление. Подсказка: используй метод setEnabled().
10.3.3.	Аналогично поступи и для пункта меню redoMenuItem, добавив метод-заглушку
canRedo() в представление.
Запусти программу и убедись, что пункты меню Отменить и Вернуть недоступны.



HTML Editor (14)

9.1.	Реализуй метод initMenuBar(). Он должен:
9.1.1.	Создавать новый объект типа JMenuBar. Это и будет наша панель меню.
9.1.2.	С помощью MenuHelper инициализировать меню в следующем порядке: Файл,
Редактировать, Стиль, Выравнивание, Цвет, Шрифт и Помощь.
9.1.3.	Добавлять в верхнюю часть панели контента текущего фрейма нашу панель меню,
аналогично тому, как это мы делали с панелью вкладок.
9.2.	Добавь конструктор класса View. Он должен устанавливать внешний вид и поведение
(look and feel) нашего приложения такими же, как это определено в системе.
Конструктор не должен кидать исключений, только логировать их с помощью
ExceptionHandler. Подсказа: для реализации задания используй класс UIManager.

Запусти приложение, теперь ты должен видеть панель с меню вверху окна. Некоторые из
пунктов меню (например: Вырезать, Копировать, Вставить, Стиль (частично), Выравнивание,
Цвет, Шрифт) должны уже работать. Убедись, что все работает и только затем продолжи
разработку.



