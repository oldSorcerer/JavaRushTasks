taskKey="com.javarush.task.task32.task3209.big15"\n\nHTML Editor (15)

Добавь в контроллер метод resetDocument(), который будет сбрасывать текущий документ. Он
должен:
15.1.	Удалять у текущего документа document слушателя правок, которые можно
отменить/вернуть (найди подходящий для этого метод, унаследованный от
AbstractDocument). Слушателя нужно запросить у представления (метод getUndoListener()).
Не забудь проверить, что текущий документ существует (не null).
15.2.	Создавать новый документ по умолчанию и присваивать его полю document.
Подсказка: воспользуйся подходящим методом класса HTMLEditorKit.
15.3.	Добавлять новому документу слушателя правок.
15.4.	Вызывать у представления метод update().


Требования:
1.	Класс Controller должен содержать публичный метод resetDocument(), который будет сбрасывать текущий документ.
2.	Метод resetDocument() должен удалять у текущего документа document слушателя правок через метод removeUndoableEditListener().
3.	Метод resetDocument() должен создавать новый документ по умолчанию через метод createDefaultDocument().
4.	Метод resetDocument() должен добавлять новому документу слушателя правок через метод addUndoableEditListener().
5.	Метод resetDocument() должен вызывать у представления метод update().


HTML Editor (15)

14.1.	Добавь в класс представления метод selectHtmlTab(). Он должен:
14.1.1.	Выбирать html вкладку (переключаться на нее).
14.1.2.	Сбрасывать все правки с помощью метода, который ты реализовал ранее.
14.2.	Добавь в класс контроллера геттер для модели, в нашем случае это поле document.
14.3.	Добавь в представление метод update(), который должен получать документ у
контроллера и устанавливать его в панель редактирования htmlTextPane.
14.4.	Добавь в представление метод showAbout(), который должен показывать диалоговое
окно с информацией о программе. Информацию придумай сам, а вот тип сообщения
должен быть JOptionPane.INFORMATION_MESSAGE.



HTML Editor (15)

Реализуем класс TextEditMenuListener в пакет listeners. Этот класс будет работать аналогично
классу UndoMenuListener только для других пунктов меню. Пункты меню, отвечающие за
стиль, шрифт, цвет и т.д. должны быть доступны только тогда, когда в нашем редакторе
выбрана первая вкладка.
13.1.	Добавь в представление метод boolean isHtmlTabSelected(). Он должен возвращать
true, если выбрана вкладка, отображающая html в панели вкладок (подсказка: ее индекс 0).
13.2.	Добавь в класс TextEditMenuListener поле View, проинициализируй его в конструкторе
класса.
13.3.	В классе TextEditMenuListener переопредели метод menuSelected(MenuEvent
menuEvent). Он должен:
13.3.1.	Из переданного параметра получать объект, над которым было совершено действие. В
нашем случае это будет объект с типом JMenu.
13.3.2.	У полученного меню получать список компонентов (пунктов меню).
13.3.3.	Для каждого пункта меню вызывать метод setEnabled, передав в качестве параметра
результат вызова метода isHtmlTabSelected() из представления.
Запусти приложение и убедись, что пункты меню стиль, выравнивание, цвет и шрифт доступны
только, когда активна закладка HTML и не доступны для закладки Текст.



HTML Editor (15)

12.1.	Напиши реализацию класса RedoAction:
12.1.1.	Добавь в класс поле View. Добавь его инициализацию в конструкторе.
12.1.2.	Реализуй метод actionPerformed(ActionEvent actionEvent), он должен вызывать метод
redo() у представления.
12.2.	Напиши реализацию класса UndoAction по аналогии с RedoAction.
12.3.	Изучи реализацию класса StrikeThroughAction, которую ты получил вместе с заданием и
реализуй аналогичным образом классы:
12.3.1.	SubscriptAction
12.3.2.	SuperscriptAction
Запусти программу и убедись, что пункты меню Подстрочный знак, Надстрочный знак и
Зачеркнутый работают. Пункты, отвечающие за отмену и возврат действия пока не
подключены к контроллеру и мы не сможем их проверить.



HTML Editor (15)

11.1.	Добавь в представление поле UndoManager undoManager. Разберись для чего
используется этот класс. Проинициализируй поле класса новым объектом.
11.2.	Добавь класс UndoListener реализующий интерфейс UndoableEditListener в пакет
listeners. Этот класс будет следить за правками, которые можно отменить или вернуть.
11.3.	Добавь в класс UndoListener:
11.3.1.	Поле UndoManager undoManager.
11.3.2.	Конструктор, который принимает UndoManager и инициализирует поле класса.
11.3.3.	Метод undoableEditHappened(UndoableEditEvent e). Он должен из переданного
события получать правку и добавлять ее в undoManager.
11.4.	Добавь в представление поле UndoListener undoListener, проинициализируй его
используя undoManager.
11.5.	Добавь в представление методы:
11.5.1.	void undo() - отменяет последнее действие. Реализуй его используя undoManager.
Метод не должен кидать исключений, логируй их.
11.5.2.	void redo() - возвращает ранее отмененное действие. Реализуй его по аналогии с
предыдущим пунктом.
11.5.3.	Реализуй методы boolean canUndo() и boolean canRedo() используя undoManager.
11.5.4.	Реализуй геттер для undoListener.
11.5.5.	Добавь и реализуй метод void resetUndo(), который должен сбрасывать все правки в
менеджере undoManager.



HTML Editor (15)

Наш редактор будет поддерживать механизм отмены/возврата (undo/redo) действий в
редакторе.
Реализуй класс UndoMenuListener. Этот слушатель будет следить за меню, а если конкретнее,
то за моментом, когда меню редактирования будет выбрано пользователем. В этот момент он
будет запрашивать у представления можем ли мы сейчас отменить или вернуть какое-то
действие, и в зависимости от этого делать доступными или не доступными пункты меню
&quot;Отменить&quot; и &quot;Вернуть&quot;.
10.1.	Добавь в класс UndoMenuListener следующие поля:
10.1.1.	Представление View view.
10.1.2.	Пункт меню &quot;Отменить&quot; JMenuItem undoMenuItem.
10.1.3.	Пункт меню &quot;Вернуть&quot; JMenuItem redoMenuItem.
10.2.	Реализуй конструктор UndoMenuListener(View view, JMenuItem undoMenuItem,
JMenuItem redoMenuItem), он должен инициализировать поля класса.
10.3.	Реализуй метод menuSelected(MenuEvent menuEvent). Он будет вызываться перед
показом меню. Он должен:
10.3.1.	Спрашивать у представления можем ли мы отменить действие с помощью метода
boolean canUndo(). Пока у представления нет такого метода, поэтому добавь заглушку,
которая всегда возвращает false.
10.3.2.	Делать доступным или не доступным пункт меню undoMenuItem в зависимости от того,
что нам вернуло представление. Подсказка: используй метод setEnabled().
10.3.3.	Аналогично поступи и для пункта меню redoMenuItem, добавив метод-заглушку
canRedo() в представление.
Запусти программу и убедись, что пункты меню Отменить и Вернуть недоступны.



