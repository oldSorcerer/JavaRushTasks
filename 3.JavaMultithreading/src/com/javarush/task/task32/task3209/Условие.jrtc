taskKey="com.javarush.task.task32.task3209.big06"\n\nHTML Editor (6)

Реализуй метод инициализации панелей редактора initEditor(). Он должен:
6.1.	Устанавливать значение &quot;text/html&quot; в качестве типа контента для компонента htmlTextPane.
Найди и используй подходящий метод.
6.2.	Создавать новый локальный компонент JScrollPane на базе htmlTextPane.
6.3.	Добавлять вкладку в панель tabbedPane с именем &quot;HTML&quot; и компонентом из предыдущего
пункта.
6.4.	Создавать новый локальный компонент JScrollPane на базе plainTextPane.
6.5.	Добавлять еще одну вкладку в tabbedPane с именем &quot;Текст&quot; и компонентом из
предыдущего пункта.
6.6.	Устанавливать предпочтительный размер панели tabbedPane.
6.7.	Создавать объект класса TabbedPaneChangeListener и устанавливать его в качестве
слушателя изменений в tabbedPane.
6.8.	Добавлять по центру панели контента текущего фрейма нашу панель с вкладками.
Получить панель контента текущего фрейма можно с помощью метода
getContentPane(), его реализация унаследовалась от JFrame.
Подумай, метод с какими параметрами необходимо вызвать, чтобы панель с вкладками отображалась
по центру панели контента текущего фрейма.
После запуска приложения можно будет увидеть текущие результаты: две независимые
закладки (HTML и Текст), в каждой из которых можно набирать свой текст.


Требования:
1.	В методе initEditor() для компонента htmlTextPane должен устанавливаться тип контента &quot;text/html&quot; через сеттер setContentType.
2.	В методе initEditor() должен создаваться новый локальный компонент JScrollPane через конструктор принимающий htmlTextPane.
3.	В методе initEditor() для компонента tabbedPane должна добавляться вкладка с именем &quot;HTML&quot; и созданным компонентом JScrollPane на базе htmlTextPane.
4.	В методе initEditor() должен создаваться новый локальный компонент JScrollPane через конструктор принимающий plainTextPane.
5.	В методе initEditor() для компонента tabbedPane должна добавляться вкладка с именем &quot;Текст&quot; и созданным компонентом JScrollPane на базе plainTextPane.
6.	В методе initEditor() для компонента tabbedPane должен устанавливаться предпочтительный размер панели, через сеттер setPreferredSize.
7.	В методе initEditor() для компонента tabbedPane должен добавляться слушатель TabbedPaneChangeListener через метод addChangeListener.
8.	Метод initEditor() должен добавлять по центру панели контента текущего фрейма нашу панель с вкладками, через getContentPane().add().


HTML Editor (6)

5.1.	Объяви класс TabbedPaneChangeListener реализующий интерфейс ChangeListener в пакете
listeners. Этот класс будет слушать и обрабатывать изменения состояния панели вкладок.
Реализуй в этом классе:
5.1.1.	Конструктор, принимающий представление в виде параметра и сохраняющий во
внутреннее поле view класса.
5.1.2.	Переопредели метод из интерфейса ChangeListener, он должен вызывать метод
selectedTabChanged() у представления. Последнего метода еще нет, сделай для него
заглушку.
5.2.	Объяви класс ExceptionHandler. Это будет наш обработчик исключительных ситуаций,
который ты в дальнейшем сможешь переопределить. Пока добавь в него статический метод
log(Exception e), который будет выводить в консоль краткое описание проблемы
(используй метод toString у переданного исключения).



HTML Editor (6)

4.1.	Объяви методы initMenuBar() и initEditor() в классе View. Они будут отвечать за
инициализацию меню и панелей редактора.
4.2.	Объяви в представлении метод initGui(). Он будет инициализировать графический
интерфейс. Вызови из него инициализацию меню initMenuBar(), инициализацию редактора
initEditor() и метод pack(), реализацию которого мы унаследовали от класса JFrame.
Разберись что делает метод pack().
4.3.	Реализуй метод init() представления. Он должен:
4.3.1.	Вызывать инициализацию графического интерфейса initGui().
4.3.2.	Добавлять слушателя событий нашего окна. В качестве подписчика создай и используй
объект класса FrameListener. В качестве метода для добавления подписчика используй
подходящий метод из класса Window, от которого наследуется и наш класс через
классы JFrame и Frame.
4.3.3.	Показывать наше окно. Используй метод setVisible с правильным параметром.
На этом этапе приложение при запуске должно показывать окно, которое можно растягивать,
разворачивать, закрыть и т.д.



HTML Editor (6)

Графический интерфейс будет представлять собой окно, в котором будет меню и панель с
двумя вкладками.
На первой вкладке будет располагаться текстовая панель, которая будет отрисовывать html
страницу. На ней можно будет форматировать и редактировать текст страницы.
На второй вкладке будет редактор, который будет отображать код html страницы, в нем будут
видны все используемые html теги. В нем также можно будет менять текст страницы,
добавлять и удалять различные теги.
3.1.	Добавь и проинициализируй поля в классе представления:
3.1.1.	JTabbedPane tabbedPane - это будет панель с двумя вкладками.
3.1.2.	JTextPane htmlTextPane - это будет компонент для визуального редактирования html.
Он будет размещен на первой вкладке.
3.1.3.	JEditorPane plainTextPane - это будет компонент для редактирования html в виде
текста, он будет отображать код html (теги и их содержимое).
3.2.	Добавь класс FrameListener в пакет listeners. Он должен:
3.2.1.	Быть унаследован от WindowAdapter.
3.2.2.	Иметь поле View view.
3.2.3.	В конструкторе принимать View и инициализировать внутреннее поле.
3.2.4.	Иметь переопределенный метод windowClosing(WindowEvent windowEvent), который
должен вызывать exit() у представления.



HTML Editor (6)

2.1.	Добавь в контроллер и представление по методу init(), пока без реализаций. Они будут
отвечать за инициализацию контроллера и представления.
2.2.	Теперь напишем в классе Controller метод main(). Он должен:
2.2.1.	Создавать объект представления.
2.2.2.	Создавать контроллер, используя представление.
2.2.3.	Устанавливать у представления контроллер.
2.2.4.	Инициализировать представление (вызывать метод init).
2.2.5.	Инициализировать контроллер (вызывать метод init). Контроллер должен инициализироваться после представления.
2.3.	Добавь в контроллер метод exit(), он должен вызывать статический метод exit у класса
System с параметром 0.
2.3.1.  Метод exit в классе Controller не должен быть статическим.
2.4.	Добавь в представление метод exit(), он должен вызывать exit() у контроллера.



HTML Editor (6)

Сегодня мы напишем HTML редактор с графическим интерфейсом. В качестве библиотеки для
создания графического интерфейса воспользуемся Swing. А в качестве архитектурного каркаса
нашего приложения будем использовать MVC модель.
1.1.	Объяви класс Controller и класс View. Класс View должен быть унаследован от JFrame и
реализовывать интерфейс ActionListener.
1.2.	Добавь в класс Controller поля, отвечающие за представление View view и модель
HTMLDocument document. Здесь и далее, классы, которые мы не объявляли, но
используем в коде скорее всего все находятся в библиотеке swing. Например, класс
HTMLDocument реализован в пакете javax.swing.text.html.
1.3.	Добавь в класс Controller поле, которое будет отвечать за файл, который сейчас открыт в
нашем редакторе (текущий файл) File currentFile.
1.4.	Добавь конструктор класса Controller. Он должен принимать в качестве параметра
представление и инициализировать соответствующее поле класса.
1.5.    Добавь в Controller пустой метод main.
1.6.	Добавь в класс View поле Controller controller.
1.7.	Добавь в класс View сеттер и геттер для поля controller.
1.8.	Добавь пустую реализацию метода, который объявлен в интерфейсе ActionListener.



