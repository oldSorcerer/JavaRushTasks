taskKey="com.javarush.task.task34.task3410.big03"\n\nSokoban (3)

Скоро мы займемся созданием различных игровых объектов. Было бы удобно иметь
возможность сразу их где-то нарисовать и посмотреть, как они выглядят. Объекты будут
рисоваться на игровом поле Field.
Тебе пришел измененный код класса View, который создает объект поля Field и
настраивает правильным образом представление View. А тебе нужно:
3.1. Добавь в пакет view класс Field, унаследованный от JPanel.
3.2. Добавь в класс Field:
3.2.1. Конструктор с параметром View view.
3.2.2. Поле View view, которое должно инициализироваться в конструкторе.
3.2.3. Создай заглушку для метода paint(Graphics g), она пока ничего не будет делать.
3.3. Добавь в конструктор класса контроллера вызов метода init() представления.
3.4. Метод main() в классе Controller должен создавать новый объект контроллера.


Требования:
1.	Добавь в пакет view класс Field, унаследованный от JPanel.
2.	Добавь в класс Field поле view типа View.
3.	Добавь в класс Field конструктор с параметром View view, инициализирующий нужное поле.
4.	Создай заглушку для метода paint(Graphics g) в классе Field.
5.	Добавь в конструктор класса контроллера вызов метода init() представления.
6.	Метод main() в классе Controller должен создавать новый объект контроллера.


Sokoban (3)

Основа заложена, теперь перейдем к ее наполнению. Игровой процесс можно представить
как взаимодействие игровых объектов GameObject. У нас их будет несколько видов: ящик
Box, дом Home (место куда нужно поместить ящик), стена Wall и игрок Player.
2.1. Добавь абстрактный класс GameObject в пакет model.
2.2. Добавь в класс GameObject поля: int x, int y, int width и int height. Это будет позиция и
размер объекта для отрисовки.
2.3. Добавь сеттеры и геттеры для полей класса.
2.4. Добавь в класс Model публичную статическую константу int FIELD_CELL_SIZE = 20, это
будет размер ячейки игрового поля. Все игровые объекты будут занимать одну ячейку
игрового поля. Именно этот размер будет участвовать в расчёте движения и
столкновений объектов. Размер, который будет храниться внутри объекта, будет
использоваться только при его отрисовке.
2.5. Добавь в класс GameObject два конструктора:
2.5.1. GameObject(int x, int y)
2.5.2. GameObject(int x, int y, int width, int height)
Конструкторы должны инициализировать все поля класса. Если width и height не переданы,
используй FIELD_CELL_SIZE в качестве ширины и высоты.
2.6. Добавь абстрактный метод void draw(Graphics graphics) в класс GameObject. Этот метод
будет реализован в каждом типе игровых объектов по-своему. Другими словами,
каждый тип игровых объектов будет знать, как он должен рисоваться и будет сам себя
рисовать в графический контекст graphics. Graphics &ndash; это абстрактный класс из
библиотеки java.awt.



Sokoban (3)

Сегодня мы напишем свою реализацию игры Сокобан. Это логическая игра-головоломка,
более подробно про нее можешь прочитать в Википедии. Игра будет состоять из 3х
основных компонентов (как ты догадался, тут не обошлось без паттерна MVC).
Графический интерфейс будет реализован с использованием Swing.
1.1. Создай пакет view и добавь в него класс View, унаследованный от JFrame. Этот класс
будет отвечать за графическое представление нашей игры.
1.2. Создай пакет model и добавь в него класс Model. Этот класс будет отвечать за модель
нашей игры. Как тебе названия классов? Правда они непредсказуемые? :) На самом
деле, очень важно назвать классы так, чтобы человек, который впервые видит твой
проект, сразу понял за что они отвечают.
1.3. Создай пакет controller и добавь в него класс Controller с конструктором по умолчанию.
1.4. Добавь в класс View конструктор, который будет принимать Controller и сохранять его
во внутреннем поле класса, которое тоже нужно добавить. Поле назови controller.
1.5. Добавь в класс Controller поля View view и Model model. Проинициализируй их в
конструкторе.
1.6. Т.к. контроллер - это наш главный класс, добавь в него метод main.



