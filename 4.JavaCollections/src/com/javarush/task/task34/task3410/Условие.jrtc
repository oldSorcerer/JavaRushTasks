taskKey="com.javarush.task.task34.task3410.big04"\n\nSokoban (4)

Общий класс игровых объектов GameObject уже есть. Пришло время создать классы конкретных типов игровых объектов.
4.1. Часть игровых объектов могут двигаться (игрок и ящики), а часть нет, например, стены и дома.
4.1.1. Добавь интерфейс Movable в пакет model.
4.1.2. Интерфейс Movable должен иметь метод void move(int x, int y).
4.2. Добавь enum Direction в пакет model. Он должен содержать следующие значения:
LEFT, RIGHT, UP и DOWN. Этот тип будет использоваться для описания направления движения объектов.
4.3. Игровые объекты типа &ldquo;дом&rdquo; не поддерживают логики столкновений (игрок или
ящики могут свободно передвигаться по ним). Что касается остальных объектов, то
они не должны проходить сквозь друг друга, они должны сталкиваться. Например,
ящик нельзя протолкнуть сквозь стену.
4.3.1. Добавь абстрактный класс CollisionObject в пакет model.
4.3.2. Класс CollisionObject должен быть унаследован от GameObject.
4.3.3. Добавь в класс CollisionObject:
4.3.3.1. Конструктор, принимающий int x и int y.
4.3.3.2. Публичный метод boolean isCollision(GameObject gameObject, Direction direction).
Этот метод должен возвращаться true, если при перемещении текущего
объекта в направлении direction на FIELD_CELL_SIZE произойдет
столкновение с объектом gameObject, переданным в качестве параметра.
Иначе &ndash; возвращать false. Столкновением считать совпадение координат x и y.


Требования:
1.	Добавь интерфейс Movable в пакет model.
2.	Интерфейс Movable должен объявлять метод void move(int x, int y).
3.	Добавь enum Direction в пакет model. Он должен содержать следующие значения: LEFT, RIGHT, UP и DOWN.
4.	Добавь абстрактный класс CollisionObject в пакет model.
5.	Класс CollisionObject должен быть унаследован от GameObject.
6.	Добавь в класс CollisionObject конструктор, принимающий int x и int y.
7.	Добавь в класс CollisionObject публичный метод boolean isCollision(GameObject gameObject, Direction direction), реализующий поведение описанное в задании.


Sokoban (4)

Скоро мы займемся созданием различных игровых объектов. Было бы удобно иметь
возможность сразу их где-то нарисовать и посмотреть, как они выглядят. Объекты будут
рисоваться на игровом поле Field.
Тебе пришел измененный код класса View, который создает объект поля Field и
настраивает правильным образом представление View. А тебе нужно:
3.1. Добавь в пакет view класс Field, унаследованный от JPanel.
3.2. Добавь в класс Field:
3.2.1. Конструктор с параметром View view.
3.2.2. Поле View view, которое должно инициализироваться в конструкторе.
3.2.3. Создай заглушку для метода paint(Graphics g), она пока ничего не будет делать.
3.3. Добавь в конструктор класса контроллера вызов метода init() представления.
3.4. Метод main() в классе Controller должен создавать новый объект контроллера.



Sokoban (4)

Основа заложена, теперь перейдем к ее наполнению. Игровой процесс можно представить
как взаимодействие игровых объектов GameObject. У нас их будет несколько видов: ящик
Box, дом Home (место куда нужно поместить ящик), стена Wall и игрок Player.
2.1. Добавь абстрактный класс GameObject в пакет model.
2.2. Добавь в класс GameObject поля: int x, int y, int width и int height. Это будет позиция и
размер объекта для отрисовки.
2.3. Добавь сеттеры и геттеры для полей класса.
2.4. Добавь в класс Model публичную статическую константу int FIELD_CELL_SIZE = 20, это
будет размер ячейки игрового поля. Все игровые объекты будут занимать одну ячейку
игрового поля. Именно этот размер будет участвовать в расчёте движения и
столкновений объектов. Размер, который будет храниться внутри объекта, будет
использоваться только при его отрисовке.
2.5. Добавь в класс GameObject два конструктора:
2.5.1. GameObject(int x, int y)
2.5.2. GameObject(int x, int y, int width, int height)
Конструкторы должны инициализировать все поля класса. Если width и height не переданы,
используй FIELD_CELL_SIZE в качестве ширины и высоты.
2.6. Добавь абстрактный метод void draw(Graphics graphics) в класс GameObject. Этот метод
будет реализован в каждом типе игровых объектов по-своему. Другими словами,
каждый тип игровых объектов будет знать, как он должен рисоваться и будет сам себя
рисовать в графический контекст graphics. Graphics &ndash; это абстрактный класс из
библиотеки java.awt.



Sokoban (4)

Сегодня мы напишем свою реализацию игры Сокобан. Это логическая игра-головоломка,
более подробно про нее можешь прочитать в Википедии. Игра будет состоять из 3х
основных компонентов (как ты догадался, тут не обошлось без паттерна MVC).
Графический интерфейс будет реализован с использованием Swing.
1.1. Создай пакет view и добавь в него класс View, унаследованный от JFrame. Этот класс
будет отвечать за графическое представление нашей игры.
1.2. Создай пакет model и добавь в него класс Model. Этот класс будет отвечать за модель
нашей игры. Как тебе названия классов? Правда они непредсказуемые? :) На самом
деле, очень важно назвать классы так, чтобы человек, который впервые видит твой
проект, сразу понял за что они отвечают.
1.3. Создай пакет controller и добавь в него класс Controller с конструктором по умолчанию.
1.4. Добавь в класс View конструктор, который будет принимать Controller и сохранять его
во внутреннем поле класса, которое тоже нужно добавить. Поле назови controller.
1.5. Добавь в класс Controller поля View view и Model model. Проинициализируй их в
конструкторе.
1.6. Т.к. контроллер - это наш главный класс, добавь в него метод main.



