taskKey="com.javarush.task.task33.task3310.big08"\n\nShortener (8)

Добавь и реализуй класс OurHashMapStorageStrategy, используя класс Entry из
предыдущей подзадачи. Класс OurHashMapStorageStrategy должен реализовывать
интерфейс StorageStrategy.
8.1. Добавь в класс следующие поля:
8.1.1. static final int DEFAULT_INITIAL_CAPACITY = 16;
8.1.2. static final float DEFAULT_LOAD_FACTOR = 0.75f;
8.1.3. Entry[] table = new Entry[DEFAULT_INITIAL_CAPACITY];
8.1.4. int size;
8.1.5. int threshold = (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
8.1.6. float loadFactor = DEFAULT_LOAD_FACTOR;
8.2. Реализуй в классе следующие вспомогательные методы:
8.2.1. int hash(Long k)
8.2.2. int indexFor(int hash, int length)
8.2.3. Entry getEntry(Long key)
8.2.4. void resize(int newCapacity)
8.2.5. void transfer(Entry[] newTable)
8.2.6. void addEntry(int hash, Long key, String value, int bucketIndex)
8.2.7. void createEntry(int hash, Long key, String value, int bucketIndex)
8.3. Добавь в класс публичные методы, которые требует интерфейс StorageStrategy.
Какие-либо дополнительные поля класса не использовать. Методы, не описанные в
задании, реализовывать не нужно. Если возникнут вопросы как реализовать какой-то
метод или что он должен делать, то ты всегда можешь посмотреть, как работает
похожий метод в HashMap.
Можешь добавить в метод main класса Solution тестирование новой стратегии. Запусти
и сравни время работы двух стратегий на одинаковом количестве элементов.


Требования:
1.	Класс OurHashMapStorageStrategy должен поддерживать интерфейс StorageStrategy.
2.	В классе OurHashMapStorageStrategy должны быть созданы все необходимые поля (согласно условию задачи).
3.	Методы интерфейса StorageStrategy должны быть реализованы в OurHashMapStorageStrategy таким образом, чтобы обеспечивать корректную работу Shortener созданного на его основе.
4.	В классе OurHashMapStorageStrategy должны присутствовать все вспомогательные методы перечисленные в условии задачи.


Shortener (8)

Приступим к реализации второй стратегии OurHashMapStorageStrategy. Она не будет
использовать готовый HashMap из стандартной библиотеки, а будет сама являться
коллекцией.

7.1.	Разберись как работает стандартный HashMap, посмотри его исходники или
погугли статьи на эту тему.
7.2.	Если ты честно выполнил предыдущий пункт, то ты знаешь для чего используется
класс Node поддерживающий интерфейс Entry внутри HashMap. Создай свой аналог внутри пакета
strategy. Это должен быть обычный, не вложенный, не generic класс. Сделай его публичным.
В отличии от класса Node из HashMap, наш класс будет поддерживать только
интерфейс Serializable и будет называться Entry.
7.3.	Добавь в Entry следующие поля: Long key, String value, Entry next, int hash. Как
видишь, наша реализация будет поддерживать только тип Long для ключа и только
String для значения. Область видимости полей оставь по умолчанию.
7.4.	Добавь и реализуй конструктор Entry(int hash, Long key, String value, Entry next).
7.5.	Добавь и реализуй методы: Long getKey(), String getValue(), int hashCode(), boolean equals() и String
toString(). Реализовывать остальные методы оригинального Entry не нужно, мы
пишем упрощенную версию.



Shortener (8)

Первая стратегия готова, пришло время ее протестить. Для этого:
6.1.	Создай класс Solution, если ты не сделал это раньше.
6.2.	Добавь в класс Solution реализации вспомогательных статических методов:
6.2.1.	Set&lt;Long&gt; getIds(Shortener shortener, Set&lt;String&gt; strings). Этот метод должен
для переданного множества строк возвращать множество идентификаторов. Идентификатор для каждой
отдельной строки нужно получить, используя shortener.
6.2.2.	Set&lt;String&gt; getStrings(Shortener shortener, Set&lt;Long&gt; keys). Метод будет
возвращать множество строк, которое соответствует переданному множеству идентификаторов.
При реальном использовании Shortener, задача получить из множества строк
множество идентификаторов и наоборот скорее всего не встретится, это нужно исключительно для тестирования.
6.2.3.	testStrategy(StorageStrategy strategy, long elementsNumber). Метод будет
тестировать работу переданной стратегии на определенном количестве
элементов elementsNumber. Реализация метода должна:
6.2.3.1.	Выводить имя класса стратегии. Имя не должно включать имя пакета.
6.2.3.2.	Генерировать тестовое множество строк, используя Helper и заданное
количество элементов elementsNumber.
6.2.3.3.	Создавать объект типа Shortener, используя переданную стратегию.
6.2.3.4.	Замерять и выводить время необходимое для отработки метода getIds
для заданной стратегии и заданного множества элементов. Время
вывести в миллисекундах. При замере времени работы метода можно
пренебречь переключением процессора на другие потоки, временем,
которое тратится на сам вызов, возврат значений и вызов методов
получения времени (даты). Замер времени произведи с
использованием объектов типа Date.
6.2.3.5.	Замерять и выводить время необходимое для отработки метода
getStrings для заданной стратегии и полученного в предыдущем пункте
множества идентификаторов.
6.2.3.6.	Сравнивать одинаковое ли содержимое множества строк, которое было
сгенерировано и множества, которое было возвращено методом
getStrings. Если множества одинаковы, то выведи &quot;Тест пройден.&quot;,
иначе &quot;Тест не пройден.&quot;.
6.2.4.	Добавь метод main(). Внутри метода протестируй стратегию
HashMapStorageStrategy с помощью 10000 элементов.
6.3.	Проверь, что программа работает и тест пройден.



Shortener (8)

Давай напишем наше первое хранилище (стратегию хранилища). Внутри оно будет
содержать обычный HashMap. Все стратегии будем хранить в пакете strategy.
5.1. Создай класс HashMapStorageStrategy, реализующий интерфейс StorageStrategy.
5.2. Добавь в класс поле HashMap&lt;Long, String&gt; data. В нем будут храниться наши данные.
5.3. Реализуй в классе все необходимые методы. Реализации методов должны
использовать поле data. Дополнительные поля не создавать.



Shortener (8)

Нам потребуется несколько вспомогательных классов:
4.1.	Создай класс Helper.
4.1.1.	Добавь в него статический публичный метод String generateRandomString(), который
будет генерировать случайную строку. Воспользуйся для этого классами
SecureRandom и BigInteger. Подсказка: гугли запрос &quot;random string java&quot;.
Строка может состоять из цифр и любой из 26 маленьких букв английского алфавита.
4.1.2.	Добавь в класс статический метод printMessage(String message). Он должен выводить
переданный текст в консоль. Весь дальнейший вывод в программе должен
быть реализован через этот метод!
4.2.	Создай класс ExceptionHandler.
4.2.1.	Добавь в него статический метод log(Exception e), который будет выводить
краткое описание исключения.



Shortener (8)

Вернемся к классу Shortener:
3.1.	Добавь в него поле Long lastId. Проинициализируй его нулем. Это поле будет
отвечать за последнее значение идентификатора, которое было использовано при
добавлении новой строки в хранилище.
3.2.	Добавь поле StorageStrategy storageStrategy в котором будет храниться стратегия
хранения данных.
3.3.	Добавь конструктор, который принимает StorageStrategy и инициализирует
соответствующее поле класса.
3.4.	Реализуй метод getId, он должен:
3.4.1.	Проверить есть ли переданное значение в хранилище, если есть &ndash; вернуть
его ключ.
3.4.2.	Если преданного значения нет в хранилище, то:
3.4.2.1.	Увеличить значение lastId на единицу;
3.4.2.2.	Добавить в хранилище новую пару ключ-значение (новое значение
lastId и переданную строку);
3.4.2.3.	Вернуть новое значение lastId.
3.5.	Реализуй метод getString, он должен вернуть строку по заданному идентификатору
(ключу).
3.6.	Предусмотреть возможность вызова методов getId и getString из разных потоков
добавив соответствующий модификатор к заголовкам методов.



