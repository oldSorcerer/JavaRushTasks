taskKey="com.javarush.task.task33.task3310.big07"\n\nShortener (7)

Приступим к реализации второй стратегии OurHashMapStorageStrategy. Она не будет
использовать готовый HashMap из стандартной библиотеки, а будет сама являться
коллекцией.

7.1.	Разберись как работает стандартный HashMap, посмотри его исходники или
погугли статьи на эту тему.
7.2.	Если ты честно выполнил предыдущий пункт, то ты знаешь для чего используется
класс Node поддерживающий интерфейс Entry внутри HashMap. Создай свой аналог внутри пакета
strategy. Это должен быть обычный, не вложенный, не generic класс. Сделай его публичным.
В отличии от класса Node из HashMap, наш класс будет поддерживать только
интерфейс Serializable и будет называться Entry.
7.3.	Добавь в Entry следующие поля: Long key, String value, Entry next, int hash. Как
видишь, наша реализация будет поддерживать только тип Long для ключа и только
String для значения. Область видимости полей оставь по умолчанию.
7.4.	Добавь и реализуй конструктор Entry(int hash, Long key, String value, Entry next).
7.5.	Добавь и реализуй методы: Long getKey(), String getValue(), int hashCode(), boolean equals() и String
toString(). Реализовывать остальные методы оригинального Entry не нужно, мы
пишем упрощенную версию.


Требования:
1.	В классе Entry должны быть созданы поля перечисленные в условии задачи.
2.	В классе Entry должен быть реализован публичный конструктор с четырьмя параметрами (int, Long, String, Entry) инициализирующий соответствующие поля класса.
3.	Метод getKey должен возвращать значение поля key.
4.	Метод getValue должен возвращать значение поля value.
5.	Метод toString должен возвращать строку формата key + &quot;=&quot; + value.
6.	Методы hashCode и equals должны быть корректно реализованы используя для сравнения поля key и value.


Shortener (7)

Первая стратегия готова, пришло время ее протестить. Для этого:
6.1.	Создай класс Solution, если ты не сделал это раньше.
6.2.	Добавь в класс Solution реализации вспомогательных статических методов:
6.2.1.	Set&lt;Long&gt; getIds(Shortener shortener, Set&lt;String&gt; strings). Этот метод должен
для переданного множества строк возвращать множество идентификаторов. Идентификатор для каждой
отдельной строки нужно получить, используя shortener.
6.2.2.	Set&lt;String&gt; getStrings(Shortener shortener, Set&lt;Long&gt; keys). Метод будет
возвращать множество строк, которое соответствует переданному множеству идентификаторов.
При реальном использовании Shortener, задача получить из множества строк
множество идентификаторов и наоборот скорее всего не встретится, это нужно исключительно для тестирования.
6.2.3.	testStrategy(StorageStrategy strategy, long elementsNumber). Метод будет
тестировать работу переданной стратегии на определенном количестве
элементов elementsNumber. Реализация метода должна:
6.2.3.1.	Выводить имя класса стратегии. Имя не должно включать имя пакета.
6.2.3.2.	Генерировать тестовое множество строк, используя Helper и заданное
количество элементов elementsNumber.
6.2.3.3.	Создавать объект типа Shortener, используя переданную стратегию.
6.2.3.4.	Замерять и выводить время необходимое для отработки метода getIds
для заданной стратегии и заданного множества элементов. Время
вывести в миллисекундах. При замере времени работы метода можно
пренебречь переключением процессора на другие потоки, временем,
которое тратится на сам вызов, возврат значений и вызов методов
получения времени (даты). Замер времени произведи с
использованием объектов типа Date.
6.2.3.5.	Замерять и выводить время необходимое для отработки метода
getStrings для заданной стратегии и полученного в предыдущем пункте
множества идентификаторов.
6.2.3.6.	Сравнивать одинаковое ли содержимое множества строк, которое было
сгенерировано и множества, которое было возвращено методом
getStrings. Если множества одинаковы, то выведи &quot;Тест пройден.&quot;,
иначе &quot;Тест не пройден.&quot;.
6.2.4.	Добавь метод main(). Внутри метода протестируй стратегию
HashMapStorageStrategy с помощью 10000 элементов.
6.3.	Проверь, что программа работает и тест пройден.



Shortener (7)

Давай напишем наше первое хранилище (стратегию хранилища). Внутри оно будет
содержать обычный HashMap. Все стратегии будем хранить в пакете strategy.
5.1. Создай класс HashMapStorageStrategy, реализующий интерфейс StorageStrategy.
5.2. Добавь в класс поле HashMap&lt;Long, String&gt; data. В нем будут храниться наши данные.
5.3. Реализуй в классе все необходимые методы. Реализации методов должны
использовать поле data. Дополнительные поля не создавать.



Shortener (7)

Нам потребуется несколько вспомогательных классов:
4.1.	Создай класс Helper.
4.1.1.	Добавь в него статический публичный метод String generateRandomString(), который
будет генерировать случайную строку. Воспользуйся для этого классами
SecureRandom и BigInteger. Подсказка: гугли запрос &quot;random string java&quot;.
Строка может состоять из цифр и любой из 26 маленьких букв английского алфавита.
4.1.2.	Добавь в класс статический метод printMessage(String message). Он должен выводить
переданный текст в консоль. Весь дальнейший вывод в программе должен
быть реализован через этот метод!
4.2.	Создай класс ExceptionHandler.
4.2.1.	Добавь в него статический метод log(Exception e), который будет выводить
краткое описание исключения.



Shortener (7)

Вернемся к классу Shortener:
3.1.	Добавь в него поле Long lastId. Проинициализируй его нулем. Это поле будет
отвечать за последнее значение идентификатора, которое было использовано при
добавлении новой строки в хранилище.
3.2.	Добавь поле StorageStrategy storageStrategy в котором будет храниться стратегия
хранения данных.
3.3.	Добавь конструктор, который принимает StorageStrategy и инициализирует
соответствующее поле класса.
3.4.	Реализуй метод getId, он должен:
3.4.1.	Проверить есть ли переданное значение в хранилище, если есть &ndash; вернуть
его ключ.
3.4.2.	Если преданного значения нет в хранилище, то:
3.4.2.1.	Увеличить значение lastId на единицу;
3.4.2.2.	Добавить в хранилище новую пару ключ-значение (новое значение
lastId и переданную строку);
3.4.2.3.	Вернуть новое значение lastId.
3.5.	Реализуй метод getString, он должен вернуть строку по заданному идентификатору
(ключу).
3.6.	Предусмотреть возможность вызова методов getId и getString из разных потоков
добавив соответствующий модификатор к заголовкам методов.



Shortener (7)

Укорачиватель Shortener будет поддерживать разные стратегии хранения данных
(строк и их идентификаторов). Все эти стратегии будут наследоваться от интерфейса
StorageStrategy. Почитай подробнее про паттерн Стратегия на Вики.
Наше хранилище будет оперировать двумя понятиями: ключ и значение. Ключом будет
идентификатор строки, а значением сама строка.

2.1.	Добавь интерфейс StorageStrategy в пакет strategy.
2.2.	Добавь в интерфейс следующие методы:
2.2.1.	boolean containsKey(Long key) &ndash; должен вернуть true, если хранилище
содержит переданный ключ.
2.2.2.	boolean containsValue(String value) - должен вернуть true, если хранилище
содержит переданное значение.
2.2.3.	void put(Long key, String value) &ndash; добавить в хранилище новую пару ключ &ndash;
значение.
2.2.4.	Long getKey(String value) &ndash; вернуть ключ для переданного значения.
2.2.5.	String getValue(Long key) &ndash; вернуть значение для переданного ключа.



